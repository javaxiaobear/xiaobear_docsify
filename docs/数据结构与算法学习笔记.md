# 1、概述

## 1、什么是数据结构

> 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及他们之间的关系和操作等相关问题的学科。
>
> 简单的说：数据结构就是把数据元素按照一定的关系组织起来的集合，用来组织和存储数据

## 2、数据结构分类

> 传统上，我们可以把数据结构分为逻辑结构和物理结构两大类。

### 1、逻辑结构

> 逻辑结构是从具体问题中抽象出来的模型，是抽象意义上的结构，按照对象中数据元素之间的相互关系分类。

1. 集合结构：集合结构中数据元素除了属于同一个集合外，他们之间没有任何其他的关系。

   

2. 线性结构：线性结构中的数据元素之间存在一对一的关系

   

3. 树形结构：树形结构中的数据元素之间存在一对多的层次关系

   

4. 图形结构：图形结构的数据元素是多对多的关系



### 2、物理结构

逻辑结构在计算机中真正的表示方式（又称为映像）称为物理结构，也可以叫做存储结构。常见的物理结构有顺序存储结构、链式存储结构。

1. 顺序存储结构：把数据元素放到地址连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的 ，比如我们常用的数组就是顺序存储结构。

   

   顺序存储结构存在一定的弊端，就像生活中排时也会有人插队也可能有人有特殊情况突然离开，这时候整个结构都处于变化中，此时就需要链式存储结构。

2. 链式存储结构：是把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的。此时，数据元素之间并不能反映元素间的逻辑关系，因此在链式存储结构中引进了一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置

   



## 3、什么是算法

> 算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法解决问题的策略
> 机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。
>
> 简单的说：根据一定的条件，对一些数据进行计算，得到需要的结果。

## 4、算法初体验

### 1、案例1

> 计算1到100的和

解法1：

```java
/**
     * 解法1：利用for循环相加
     * @param n
     * @return
     */
public int getSum(int n){
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;
}
```

解法2：

```java
/**
     * 利用高斯定理
     * @param n
     * @return
     */
public int getSum2(int n){
    int sum = (n + 1)*n/2;
    return sum;
}
```

> 第一种解法要完成需求，要完成以下几个动作：
> 1.定义两个整型变量；
> 2.执行100次加法运算；
> 3.打印结果到控制台；

> 第二种解法要完成需求，要完成以下几个动作：
> 1.定义两个整型变量；
> 2.执行1次加法运算，1次乘法运算，一次除法运算，总共3次运算；
> 3.打印结果到控制台；

很明显，第二种算法完成需求，花费的时间更少一些。

### 2、案例2

> 计算10的阶乘

解法1：

```java
/**
     * 利用递归计算
     * @param n
     * @return
     */
public int getFactorial(int n){
    if(1 == n){
        return 1;
    }
    return n * getFactorial(n - 1);
}
```

解法2：

```java
  public int getFactorial2(int n){
        int sum = 1;
        for (int i = 1; i <= n; i++) {
            sum *= i;
        }
        return sum;
    }
```

> 第一种解法，使用递归完成需求，fun1方法会执行10次，并且第一次执行未完毕，调用第二次执行，第二次执行未完毕，调用第三次执行...最终，最多的时候，需要在栈内存同时开辟10块内存分别执行10个fun1方法。

> 第二种解法，使用for循环完成需求，fun2方法只会执行一次，最终，只需要在栈内存开辟一块内存执行fun2方法
> 即可。

很明显，第二种算法完成需求，占用的内存空间更小。



# 2、算法分析

> 研究算法的最终目的就是如何花更少的时间，如何占用更少的内存去完成相同的需求，并且也通过案例演示了不同算法之间时间耗费和空间耗费上的差异，但我们并不能将时间占用和空间占用量化，因此，接下来我们要学习有关算法时间耗费和算法空间耗费的描述和分析。有关算法时间耗费分析，我们称之为算法的时间复杂度分析，有关算法的空间耗费分析，我们称之为算法的空间复杂度分析。

## 1、时间复杂度

### 1、大O记法

> 在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随着n的变化情况并确定T(n)的量级。算法的时间复杂度，就是算法的时间量度，记作:T(n)=O(f(n))。它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率同，称作算法的渐近时间复杂度，简称时间复杂度，其中f(n)是问题规模n的某个函数。
> 在这里，我们需要明确一个事情：执行次数=执行时间
> 用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。

案例1：

```java
public static void main(String[] args) {
    int sum = 0;//执行1次
    int n=100;//执行1次
    sum = (n+1)*n/2;//执行1次
    System.out.println("sum="+sum);
}
```

案例2：

```java
public static void main(String[] args) {
    int sum = 0;//执行1次
    int n=100;//执行1次
    for (int i = 1; i <= n; i++) {
        sum += i;//执行了n次
    }
    System.out.println("sum=" + sum);
}
```

案例3：

```java
public static void main(String[] args) {
    int sum=0;//执行1次
    int n=100;//执行1次
    for (int i = 1; i <=n ; i++) {
        for (int j = 1; j <=n ; j++) {
            sum+=i;//执行n^2次
        }
    }
    System.out.println("sum="+sum);
}
```

如果忽略判断条件的执行次数和输出语句的执行次数，那么当输入规模为n时，以上算法执行的次数分别为：
案例一：3次
案例二：n+3次
案例三：n^2+2次

基于我们对函数渐近增长的分析，推导大O阶的表示法有以下几个规则可以使用：

1. 用常数1取代运行时间中的所有加法常数；
2. 在修改后的运行次数中，只保留高阶项；
3. 如果最高阶项存在，且常数因子不为1，则去除与这个项相乘的常数；

所以，对应上面的3个案例为：

案例1：O(1)

案例1：O(n)

案例1：O(n^2)



### 2、常见的大O阶

#### 1、线性阶

> 一般含有非嵌套循环涉及线性阶，线性阶就是随着输入规模的扩大，对应计算次数呈直线增长

```java
public static void main(String[] args) {
    int sum = 0;
    int n=100;
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    System.out.println("sum=" + sum);
}
```

上面这段代码，它的循环的时间复杂度为O(n),因为循环体中的代码需要执行n次

#### 2、平方阶

> 一般嵌套循环属于这种时间复杂度

```java
public static void main(String[] args) {
    int sum=0,n=100;
    for (int i = 1; i <=n ; i++) {
        for (int j = 1; j <=n ; j++) {
            sum+=i;
        }
    }
    System.out.println(sum);
}
```

上面这段代码，n=100，也就是说，外层循环每执行一次，内层循环就执行100次，那总共程序想要从这两个循环出来，就需要执行100100次，也就是n的平方次，所以这段代码的时间复杂度是O(n^2).*

#### 3、立方阶

> 一般三层嵌套循环属于这种时间复杂度

```java
public static void main(String[] args) {
    int x=0,n=100;
    for (int i = 1; i <=n ; i++) {
        for (int j = i; j <=n ; j++) {
            for (int j = i; j <=n ; j++) {
                x++;
            }
        }
    }
    System.out.println(x);
}
```

上面这段代码，n=100，也就是说，外层循环每执行一次，中间循环循环就执行100次，中间循环每执行一次，最内层循环需要执行100次，那总共程序想要从这三个循环中出来，就需要执行100100100次，也就是n的立方，所以这段代码的时间复杂度是O(n^3).

#### 4、对数阶

> 对数，属于高中数学的内容，我们分析程序以程序为主，数学为辅

```java
int i=1,n=100;
while(i<n){
    i = i*2;
}
```

由于每次i2之后，就距离n更近一步，假设有x个2相乘后大于n，则会退出循环。由于是2^x=n,得到x=log(2)n,所以这个循环的时间复杂度为O(logn);*

#### 5、常数阶

> 一般不涉及循环操作的都是常数阶，因为它不会随着n的增长而增加操作次数。

```java
public static void main(String[] args) {
    int n=100;
    int i=n+2;
    System.out.println(i);
}
```

上述代码，不管输入规模n是多少，都执行2次，根据大O推导法则，常数用1来替换，所以上述代码的时间复杂度为O(1)



复杂程度从低到高依次为：O(1)<O(logn)<O(n)<O(nlogn)<O(n2)<O(n3)

### 3、函数调用的时间复杂度分析

案例1：

```java
public static void main(String[] args) {
    int n=100;
    for (int i = 0; i < n; i++) {
        show(i);
    }
}
private static void show(int i) {
    System.out.println(i);
}
```

> 在main方法中，有一个for循环，循环体调用了show方法，由于show方法内部只执行了一行代码，所以show方法的时间复杂度为O(1),那main方法的时间复杂度就是O(n)

案例2：

```java
public static void main(String[] args) {
    int n=100;
    for (int i = 0; i < n; i++) {
        show(i);
    }
}
private static void show(int i) {
    for (int j = 0; j < i; i++) {
        System.out.println(i);
    }
}
```

> 在main方法中，有一个for循环，循环体调用了show方法，由于show方法内部也有一个for循环，所以show方法的时间复杂度为O(n),那main方法的时间复杂度为O(n^2)

案例3：

```java
public static void main(String[] args) {
    int n=100;
    show(n);
    for (int i = 0; i < n; i++) {
        show(i);
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            System.out.println(j);
        }
    }
}
private static void show(int i) {
    for (int j = 0; j < i; i++) {
        System.out.println(i);
    }
}
```

> 在show方法中，有一个for循环，所以show方法的时间复杂度为O(n),在main方法中，show(n)这行代码内部执行的次数为n，第一个for循环内调用了show方法，所以其执行次数为nn,第二个嵌套for循环内只执行了一行代码，所以其执行次数为nn,那么main方法总执行次数为n+n2+n2=2nn+n。根据大O推导规则，去掉n保留最高阶项，并去掉最高阶项的常数因子2，所以最终main方法的时间复杂度为O(n^2)*

### 4、最坏的情况

有一个存储了n个随机数字的数组，请从中查找出指定的数字。

```java
public int search(int num){
    int[] arr={11,10,8,9,7,22,23,0};
    for (int i = 0; i < arr.length; i++) {
        if (num==arr[i]){
            return i;
        }
    }
    return -1;
}
```

*最好的情况：查找的第一个数字就是期望的数字，那么算法的时间复杂度为O(1)*

*最坏的情况：查找的最后一个数字，才是期望的数字，那么算法的时间复杂度为O(n)*

*平均情况：任何数字查找的平均成本是O(n/2)*



## 2、空间复杂度

### 1、Java中常见的内存占用

| 数据类型 | 占用字节数 |
| -------- | ---------- |
| byte     | 1          |
| short    | 2          |
| int      | 4          |
| long     | 8          |
| float    | 4          |
| double   | 8          |
| boolean  | 1          |
| char     | 2          |

*一个引用（机器地址）需要8个字节表示：*

例如： Date date = new Date(),则date这个变量需要占用8个字节来表示

- 创建一个对象，比如new Date()，除了Date对象内部存储的数据(例如年月日等信息)占用的内存，该对象本身也有内存开销，每个对象的自身开销是16个字节，用来保存对象的头信息。
- 一般内存的使用，如果不够8个字节，都会被自动填充为8字节
- java中数组被被限定为对象，他们一般都会因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要24字节的头信息(16个自己的对象开销，4字节用于保存长度以及4个填充字节)再加上保存值所需的内存。

### 2、空间复杂度

算法的空间复杂度计算公式记作：S(n)=O(f(n))，其中n为输入规模，f(n)为语句关于n所占存储空间的函数。

*案例：对指定的数组元素进行反转，并返回反转的内容。*

解法1：

```java
public static int[] reverse2(int[] nums){
    int n = nums.length;//申请4个字节
    int temp;//申请4个字节
    for (int start = 0,end = n-1; start < end; start++,end--) {
        temp = nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
    }
    return nums;
}
```

解法2：

```java
/**
     * 数组反转
     * @param nums
     * @return
     */
public static int[] reverse(int[] nums){
    int n = nums.length;//申请4个字节
    int[] resultArr = new int[n];//申请n*4个字节+数组自身头信息开销24个字节
    for (int i = n - 1; i >= 0; i--) {
        resultArr[n - 1 - i] = nums[i];
    }
    return resultArr;
}
```

解法1：不管传入的数组大小为多少，始终额外申请4+4=8个字节；空间复杂度为O(1)

解法2：4+4n+24=4n+28；空间复杂度为O(n)

从空间占用的角度讲，解法一要优于解法二

# 3、简单排序

## 1、Comparable接口介绍

> Comparable接口用于元素之间的比较

回顾：

### 1、需求

1. 定义一个学生类Student，具有年龄age和姓名username两个属性，并通过Comparable接口提供比较规则；
2. 定义测试类Test，在测试类Test中定义测试方法Comparable getMax(Comparable c1,Comparable c2)完成测试

- Student类

  ```java
  public class Student implements Comparable<Student>{
  
      public String name;
  
      public int age;
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
      public int getAge() {
          return age;
      }
  
      public void setAge(int age) {
          this.age = age;
      }
  
      @Override
      public String toString() {
          final StringBuilder sb = new StringBuilder("Student{");
          sb.append("name='").append(name).append('\'');
          sb.append(", age=").append(age);
          sb.append('}');
          return sb.toString();
      }
      @Override
      public int compareTo(Student s){
          return this.getAge() - s.getAge();
      }
  }
  ```

- 测试类

  ```java
  public class TestCompare {
      public static void main(String[] args) {
          Student s1 = new Student();
          s1.setName("lwh");
          s1.setAge(18);
          Student s2 = new Student();
          s1.setName("yhx");
          s1.setAge(19);
          Comparable comparable = compareMax(s1, s2);
          System.out.println(comparable);
      }
  
      /**
       * 比较大小
       * @param c1
       * @param c2
       * @return
       */
      public static Comparable compareMax(Comparable c1,Comparable c2){
          int i = c1.compareTo(c2);
          /**
           * i > 0,c1 > c2
           * i == 0,c1 == c2
           * i < 0,c1 < c2
           */
          if(i >= 0){
              return c1;
          }else {
              return c2;
          }
      }
  }
  ```

## 2、冒泡排序

> 冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢"浮"到数列的顶端。

### 1、算法步骤

> 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
>
> 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
>
> 针对所有的元素重复以上的步骤，除了最后一个。
>
> 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。





### 2、代码实现

```java
/**
     * 冒泡排序算法 比较并交换
     * @param nums
     * @return
     */
public int[] bubbleSort(int[] nums){
    int n = nums.length;
    for (int i = n - 1; i >= 0; i--) {
        for (int j = 0; j < i; j++) {
            //交换两个元素
            if(nums[j] > nums[j+1]){
                int temp = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = temp;
            }
        }
    }
    return nums;
}
```

### 3、时间复杂度分析

冒泡排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码。

元素的比较次数：(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)(N-1)/2 = N2/2-N/2；*

元素的交换次数：(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)(N-1)/2 = N2/2-N/2;*

总的执行次数：N^N - N

按照大O推导法则，保留函数中的最高阶项那么最终冒泡排序的时间复杂度为O(N2).

## 2、选择排序

>  选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度

### 1、算法步骤

> 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
>
> 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
>
> 重复第二步，直到所有元素均排序完毕。





### 2、代码实现

```java
public int[] selectSort(int[] nums){
    int n = nums.length;
    //这里n-2是因为最后一次是跟自己比较
    for (int i = 0; i <= n-2; i++) {
        int index = i;
        //每一次内层循环找到最小元素的下标，如果不与i相等，则交换元素
        for (int j = i + 1; j < n; j++) {
            if(nums[index] > nums[j]){
                index = j;
            }
        }
        //交换元素
        if(i != index){
            int temp = nums[i];
            nums[i] = nums[index];
            nums[index] = temp;
        }
    }
    return nums;
}
```

### 3、时间复杂度分析

> 选择排序使用了双层for循环，其中外层循环完成了数据交换，内层循环完成了数据比较

元素比较次数：（n-1）+(n-2)+……+1 =((n-1)+1)(n-1)/2 = n2/2 - n/2*

元素交换次数：（n-1）

总的执行次数： n2/2 - n/2 + （n-1） =  n2/2 + n/2 -1

根据大O推导法则，保留最高阶项，去除常数因子，时间复杂度为O(n2)

## 3、插入排序

> *插入排序：是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。*
>
> 插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。

插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。

### 1、算法步骤

> 1. 把所有的元素分为两组，已经排序的和未排序的；
> 2. 找到未排序的组中的第一个元素，向已经排序的组中进行插入；
> 3. 倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位；





### 2、代码实现

````java
/**
     * 插入排序
     * @param nums
     * @return
     */
public int[] insertSort(int[] nums){
    int n = nums.length;
    // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的
    for(int i=1;i < n;i++){
        //当前元素为a[i],依次和i前面的元素比较，找到一个小于等于a[i]的元素
        for (int j = i; j > 0; j--) {
            //交换元素
            if(nums[j] < nums[j-1]){
                int temp = nums[j];
                nums[j] = nums[ j-1];
                nums[j-1] = temp;
            }else {
                break;
            }
        }
    }
    return nums;
}
````

### 3、时间复杂度分析

> 插入排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码

最坏的情况：就是原数组倒叙排列

比较的次数：（n-1）+(n-2)+……+1 =((n-1)+1)(n-1)/2 = n2/2 - n/2*

交换的次数：（n-1）+(n-2)+……+1 =((n-1)+1)(n-1)/2 = n2/2 - n/2*

总执行次数：n2 - n

按照大O推导法则，保留函数中的最高阶项那么最终插入排序的时间复杂度为O(n2)



# 4、高级排序

## 1、希尔排序

> 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。
>
> 希尔排序是基于插入排序的以下两点性质而提出改进方法的：
>
> - 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
> - 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；
>
> 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。

### 1、算法步骤

> 1. 选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组；
> 2. 对分好组的每一组数据完成插入排序；
> 3. 减小增长量，最小减为1，重复第二步操作。





*增长量h的确定：*

1. 先假设h=1
2. 如果h的值小于数组长度的一半，则h = 2h+1，直到大于数组长度的一半，即为增长量的值*
3. 每次循环之后，h变为原来的一半

```java
int h=1
while(h<5){
h=2h+1；//3,7
}
//循环结束后我们就可以确定h的最大值；
//h的减小规则为：
h=h/2
```

### 2、代码实现

```java
public int[] hillSort(int[] nums){
    //先确定增长量的值
    int n = nums.length;
    int index = 1;
    while(index < n/2){
        index = 2*index + 1;
    }
    while(1 <= index){
        for (int i = index; i < n; i++) { 
            for (int j = i; j >= index; j -= index) {
                if(nums[j] < nums[j - index]){
                    int temp = nums[j];
                    nums[j] = nums[j-index];
                    nums[j-index] = temp;
                }else {
                    break;
                }
            }
        }
        index = index/2;
    }
    return nums;
}
```



## 2、归并排序

> 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。
>
> 作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：
>
> - 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；
> - 自下而上的迭代；

### 1、算法步骤

> 1. 尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止。
> 2. 将相邻的两个子组进行合并成一个有序的大组；
> 3. 不断的重复步骤2，直到最终只有一个组为止。





### 2、代码实现

Arrays.copyOfRange：主要用于对一个已有的数组进行截取复制，复制出一个左闭右开区间的数组。



```java
public int[] sort(int[] nums){
    if(1 == nums.length){
        return nums;
    }
    int mid = nums.length/2;
    //将原来数组拆分成左右两个数组
    int[] left = Arrays.copyOfRange(nums,0,mid);
    int[] right = Arrays.copyOfRange(nums,mid,nums.length);
    return mergeSort(sort(left),sort(right));
}

/**
     *
     * @param left 左边数组
     * @param right 右边数组
     * @return
     */
public int[] mergeSort(int[] left,int[] right){
    //初始化结果数组
    int[] result = new int[left.length+right.length];
    int i = 0;
    while(0 < left.length && 0 < right.length){
        if(left[0] <= right[0]){
            result[i++] = left[0];
            left = Arrays.copyOfRange(left,1,left.length);
        }else {
            result[i++] = right[0];
            right = Arrays.copyOfRange(right,1,right.length);
        }
    }
    //这里主要是把落单的元素排到最后面
    while(0 < left.length){
        result[i++] = left[0];
        left = Arrays.copyOfRange(left,1,left.length);
    }
    while(0 < right.length){
        result[i++] = right[0];
        right = Arrays.copyOfRange(right,1,right.length);
    }
    return result;
}
```

## 3、快速排序

> 快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。
>
> 快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。
>
> 它是处理大数据最快的排序算法之一。

> 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。

### 1、算法步骤

> 1. 首先设定一个分界值，通过该分界值将数组分成左右两部分；
> 2. 将大于或等于分界值的数据放到到数组右边，小于分界值的数据放到数组的左边。此时左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值；
> 3. 然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。
> 4. 重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左侧和右侧两个部分的数据排完序后，整个数组的排序也就完成了。





*切分原理：*

1. 找一个基准值，用两个指针分别指向数组的头部和尾部；
2. 先从尾部向头部开始搜索一个比基准值小的元素，搜索到即停止，并记录指针的位置；
3. 再从头部向尾部开始搜索一个比基准值大的元素，搜索到即停止，并记录指针的位置；
4. 交换当前左边指针位置和右边指针位置的元素；
5. 重复2,3,4步骤，直到左边指针的值大于右边指针的值停止。

### 2、代码实现

```java
public int[] quickSort(int[] arr, int left, int right){
    if(left < right){
        //获取基准值
        int partition = partition(arr, left, right);
        quickSort(arr,left,partition-1);
        quickSort(arr,partition+1,right);
    }
    return arr;
}

/**
     * 设置基准值并排序
     * @param nums
     * @param left
     * @param right
     * @return 下一轮基准值
     */
public int partition(int[] nums, int left, int right){
    //基准值下标
    int pivot = left;
    //开始比较下标
    int index = pivot + 1;
    for (int i = index; i < nums.length; i++) {
        if(nums[pivot] > nums[i]){
            //交换元素
            swap(nums,i,index);
            //原基准值下标 = index - 1
            index++;
        }
    }
    swap(nums,pivot,index - 1);
    return index - 1;
}

/**
     * 交换元素
     * @param nums 数组
     * @param pivot
     * @param i
     */
public void swap(int[] nums, int pivot, int i){
    int temp = nums[pivot];
    nums[pivot] = nums[i];
    nums[i] = temp;
}
```

解二：

```java
public stati int[] quickSort1(int[] nums, int start, int end){
    int left = start, right = end;
    int pivot = nums[(start+end)/ 2];
    while (left <= right){
        while (left<= right && nums[left] < pivot){
            left++;
        }
        while (left <= right && nums[left] > pivot){
            right++;
        }
        if(left <= right){
            int temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;

            left++;
            right--;
        }
        quickSort(nums,start,right);
        quickSort(nums,left,end);
    }
    return nums;
}
```



### 3、快速排序和归并排序的区别：

>  快速排序是另外一种分治的排序算法，它将一个数组分成两个子数组，将两部分独立的排序。
>
> 快速排序和归并排序是互补的：
>
> - 归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序。
> - 而快速排序的方式则是当两个数组都有序时，整个数组自然就有序了。
> - 在归并排序中，一个数组被等分为两半，归并调用发生在处理整个数组之前。
> - 在快速排序中，切分数组的位置取决于数组的内容，递归调用发生在处理整个数组之后。

# 5、线性表

> 线性表是最基本、最简单、也是最常用的一种数据结构。一个线性表是n个具有相同特性的数据元素的有限序列。



*前驱元素：若A元素在B元素的前面，则称A为B的前驱元素*

*后继元素：若B元素在A元素的后面，则称B为A的后继元素*

*线性表的特征：数据元素之间具有一种“一对一”的逻辑关系。*

- 第一个数据元素没有前驱，这个数据元素被称为头结点；
2. 最后一个数据元素没有后继，这个数据元素被称为尾结点；
3. 除了第一个和最后一个数据元素外，其他数据元素有且仅有一个前驱和一个后继。

如果把线性表用数学语言来定义，则可以表示为(a1,...ai-1,ai,ai+1,...an)，ai-1领先于ai,ai领先于ai+1，称ai-1是ai的前驱元素，ai+1是ai的后继元素



*线性表的分类：*

- 存储结构
  - 顺序存储
  - 链式存储
- 存储方式
  - 顺序表
  - 链表

常见的线性结构：数组、队列、链表和栈

## 1、顺序表

> 顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存储线性表中的各个元素、使得线性表中再逻辑结构上响铃的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。



### 1、顺序表的实现

#### 1、API设计

| 类名     | SequenceCase                                                 |
| -------- | ------------------------------------------------------------ |
| 构造方法 | SequenceCase(int capacity)：创建容量为capacity的SequenceList对象 |
| 成员方法 | public void clear()：空置线性表<br/>public boolean isEmpty()：判断线性表是否为空，是返回true，否返回false<br/>public int length():获取线性表中元素的个数<br/>public T get(int i):读取并返回线性表中的第i个元素的值<br/>public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。<br/>public void insert(T t):向线性表中添加一个元素t<br/>public T remove(int i):删除并返回线性表中第i个数据元素。<br/>public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1。 |
| 成员变量 | private T[] arr：存储元素的数组<br/>private int N:当前线性表的长度 |

#### 2、代码实现

```java
public class SequenceCase<T> {

    /**
     * 存储线性表
     */
    public T[] arr;

    /**
     * 线性表元素个数
     */
    public int sequenceLength;

    public SequenceCase(int capacity) {
        arr = (T[]) new Object[capacity];
        sequenceLength = 0;
    }

    /**
     * 插入元素
     * @param name
     */
    public void insert(T name){
        if(sequenceLength == arr.length){
            throw new RuntimeException("线性表已满");
        }
        arr[sequenceLength++] = name;
    }

    /**
     * 指定索引插入元素
     * @param i
     * @param name
     */
    public void insert(int i, T name){
        if (i == arr.length){
            throw new RuntimeException("当前表已满");
        }
        if (i < 0 || i > sequenceLength){
            throw new RuntimeException("插入的位置不合法");
        }
        for (int j = sequenceLength; j > i; j--) {
            arr[j] = arr[j-1];
        }
        arr[i] = name;
        sequenceLength++;
    }

    /**
     * 根据索引删除元素
     * @param i
     */
    public T remove(int i){
        if (i < 0 || i > sequenceLength-1){
            throw new RuntimeException("当前要删除的元素不存在");
        }
        T t = arr[i];
        for (int j = i; j < sequenceLength; j++) {
            arr[j] = arr[j+1];
        }
        sequenceLength--;
        return t;
    }

    /**
     * 清空整个线性表
     */
    public void clear(){
        sequenceLength = 0;
    }

    /**
     * 线性表是否为空
     * @return
     */
    public boolean isEmpty(){
        return 0 == sequenceLength;
    }

    /**
     * 获取线性表的长度
     * @return
     */
    public int getSequenceLength(){
        return sequenceLength;
    }

    /**
     * 根据索引查询线性表
     * @param i
     * @return
     */
    public T getNameByIndex(int i){
        if(0 > i || i > sequenceLength){
            throw new RuntimeException("未存在该元素");
        }
        return arr[i];
    }

    /**
     * 获取线性表首次出现的序列号
     * @param t
     * @return
     */
    public int indexOf(T t){
        for (int i = 0; i < sequenceLength; i++) {
            if (t.equals(arr[i])){
                return i;
            }
        }
        return -1;
    }
}
```

```java
public class SequenceCaseTest {
    public static void main(String[] args) {
        SequenceCase<String> aCase = new SequenceCase<>(10);
        aCase.insert("yhx");
        aCase.insert("xiaobear");
        aCase.insert("lwh");
        aCase.insert("xiaohuahua");
        aCase.insert(2,"love");
        String nameByIndex = aCase.getNameByIndex(2);
        System.out.println("索引2的名字为：" + nameByIndex);
        String remove = aCase.remove(2);
        System.out.println("删除索引2的元素名称为：" + remove);
        //清空操作
        aCase.clear();
        System.out.println("线性表长度为：" + aCase.getSequenceLength());
    }
}
```

### 2、顺序表的遍历

> 在java中，遍历集合的方式一般都是用的是foreach循环，如果想让我们的SequenceList也能支持foreach循环，则需要做如下操作：
>
> - 让SequenceList实现Iterable接口，重写iterator方法；
> - 在SequenceList内部提供一个内部类SIterator,实现Iterator接口，重写hasNext方法和next方法；

```java
public class SequenceCase<T> implements Iterable<T>{
        private class SequenceIterator implements Iterator{

        private int temp;

        //遍历从0开始
        public SequenceIterator() {
            this.temp = 0;
        }

        @Override
        public boolean hasNext() {
            return temp < sequenceLength;
        }

        @Override
        public Object next() {
            return arr[temp++];
        }
    }

    @Override
    public Iterator<T> iterator() {
        return new SequenceIterator();
    }
}
```

### 3、顺序表的扩容

> 在之前的实现中，当我们使用SequenceCase时，先new SequenceCase(5)创建一个对象，创建对象时就需要指定容器的大小，初始化指定大小的数组来存储元素，当我们插入元素时，如果已经插入了5个元素，还要继续插入数据，则会报错，就不能插入了。这种设计不符合容器的设计理念，因此我们在设计顺序表时，应该考虑它的容量的伸缩性。

#### 1、添加元素

> 添加元素时，应该检查当前数组的大小是否能容纳新的元素，如果不能容纳，则需要创建新的容量更大的数组，我们这里创建一个是原数组两倍容量的新数组存储元素。



#### 2、删除元素

> 移除元素时，应该检查当前数组的大小是否太大，比如正在用100个容量的数组存储10个元素，这样就会造成内存空间的浪费，应该创建一个容量更小的数组存储元素。如果我们发现数据元素的数量不足数组容量的1/4，则创建一个是原数组容量的1/2的新数组存储元素。



```java
/**
     * 重置线性表大小
     * @param newSize
     */
public void resize(int newSize){
    T[] temp = arr;
    arr = (T[]) new Object[newSize];
    for (int i = 0; i < temp.length; i++) {
        arr[i] = temp[i];
    }
}
```

添加元素时：

```java
/**
     * 指定索引插入元素
     * @param i
     * @param name
     */
public void insert(int i, T name){
    if (i == arr.length){
        resize(arr.length*2);
    }
    if (i < 0 || i > sequenceLength){
        throw new RuntimeException("插入的位置不合法");
    }
    for (int j = sequenceLength; j > i; j--) {
        arr[j] = arr[j-1];
    }
    arr[i] = name;
    sequenceLength++;
}
```

删除元素时：

```java
/**
     * 根据索引删除元素
     * @param i
     */
public T remove(int i){
    if (i < 0 || i > sequenceLength-1){
        throw new RuntimeException("当前要删除的元素不存在");
    }
    T t = arr[i];
    for (int j = i; j < sequenceLength; j++) {
        arr[j] = arr[j+1];
    }
    sequenceLength--;
    //当线性表元素不足数组的1/4时，重置数组元素大小
    if(0 < sequenceLength && sequenceLength < arr.length/4){
        resize(arr.length/2);
    }
    return t;
}
```

### 4、顺序表的时间复杂度

> - get(i):不难看出，不论数据元素量N有多大，只需要一次eles[i]就可以获取到对应的元素，所以时间复杂度为O(1);
>
> - insert(int i,T t):每一次插入，都需要把i位置后面的元素移动一次，随着元素数量N的增大，移动的元素也越多，时间复杂为O(n);
> - remove(int i):每一次删除，都需要把i位置后面的元素移动一次，随着数据量N的增大,移动的元素也越多，时间复杂度为O(n);
> - 由于顺序表的底层由数组实现，数组的长度是固定的，所以在操作的过程中涉及到了容器扩容操作。这样会导致顺序表在使用过程中的时间复杂度不是线性的，在某些需要扩容的结点处，耗时会突增，尤其是元素越多，这个问题越明显



## 2、链表

> 链表是一种线性数据结构，其中的每个元素实际上是一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起。
>
> 链表是一种物理存储单元上非连续、非顺序的存储结构，其物理结构不能只管的表示数据元素的逻辑顺序，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列的结点（链表中的每一个元素称为结点）组成，结点可以在运行时动态生成。

```java
public class LinkedList<T>{

    /**
     * 存储元素
     */
    private T item;

    /**
     * 指向下一节点
     */
    private LinkedList next;

    public LinkedList(T item, LinkedList next) {
        this.item = item;
        this.next = next;
    }
}
```



### 1、单链表

> 单链表中的每个结点不仅包含值，还包含链接到下一个结点的引用字段。通过这种方式，单链表将所有结点按顺序组织起来。
>
> 单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据，指针域用来指向其后继结点。链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。



#### 1、添加元素

如果我们想在给定的结点 prev 之后添加新值，我们应该：

1. 使用给定值初始化新结点 cur；

   

2. 将 cur 的 next 字段链接到 prev 的下一个结点 next ；

   

3. 将 prev 中的 next 字段链接到 cur 。

   

与数组不同，我们不需要将所有元素移动到插入元素之后。因此，我们可以在 O(1) 时间复杂度中将新结点插入到链表中，这非常高效。

在开头添加节点

我们使用头结点开始遍历整个链表，头结点对我们来说是非常重要的。

步骤：

1. 初始化一个新节点cur
2. 将新节点链接到我们的原始节点head
3. 将cur指定为head

#### 2、删除元素



让我们尝试把结点 6从上面的单链表中删除。

1. 从头遍历链表，直到我们找到前一个结点 prev，即结点 23

2. 将 prev（结点 23）与 next（结点 15）链接



结点 6 现在不在我们的单链表中。

#### 3、代码实现

```java
public class SinglyListNode<T> implements Iterable<T> {

    /**
     * 记录头结点
     */
    private LinkedList head;

    /**
     * 链表长度
     */
    private int n;

    public SinglyListNode() {
        head = new LinkedList(null,null);
        n = 0;
    }

    /**
     * 清空链表
     * 头结点.next 指向下一节点为空，头结点元素为空，链表长度为空
     */
    public void clear(){
        head.next = null;
        head.item = null;
        n = 0;
    }

    /**
     * 链表长度
     * @return n
     */
    public int length(){
        return n;
    }

    /**
     * 判断链表是否为空
     * @return
     */
    public boolean isEmpty(){
        return n==0;
    }

    /**
     * 链表增加元素，最后节点
     * @param t 元素
     */
    public void insertNode(T t){
        //获取头结点
        LinkedList linkedList = head;
        //寻找最后一个节点
        while(null != linkedList.next){
            linkedList = linkedList.next;
        }
        //初始化插入的节点,下一节点为空
        LinkedList linkedList1 = new LinkedList(t, null);
        //最后节点的next指向下一节点
        linkedList.next = linkedList1;
        //链表长度+1
        n++;
    }

    /**
     * 指定位置插入元素
     * @param i 插入位置
     * @param t 元素
     */
    public void insertNode(int i,T t){
        //获取头结点
        LinkedList pre = head;
        //获取插入元素的前一节点
        for (int j = 0; j < i; j++) {
            pre = pre.next;
        }
        //获取下一节点（位于i的节点）
        LinkedList next = pre.next;
        //初始化插入节点，且next指向插入元素的下一节点（位于i的节点）
        LinkedList tLinkedList = new LinkedList(t, next);
        //插入元素的前一节点指向插入元素
        pre.next = tLinkedList;
        //链表长度+1
        n++;
    }

    /**
     * 删除指定位置的节点
     * @param i
     */
    public T delete(int i){
        //获取头结点
        LinkedList pre = head;
        for (int j = 0; j < i; j++) {
            pre = pre.next;
        }
        //当前i位置的结点
        LinkedList next = pre.next;
        //前一个结点指向下一个结点，删除当前结点
        pre.next = next.next;
        //长度-1
        n--;
        return next.item;
    }

    public T getIndexOf(int i){
        LinkedList pre = head;
        for (int j = 0; j < i; j++) {
            pre = pre.next;
        }
        LinkedList next = pre.next;
        return next.item;
    }

    private class LinkedList{

        /**
         * 存储元素
         */
        T item;

        /**
         * 指向下一节点
         */
       LinkedList next;

        public LinkedList(T item,LinkedList next) {
            this.item = item;
            this.next = next;
        }
    }

    @Override
    public Iterator<T> iterator() {
        return new LIterator();
    }

    private class LIterator implements Iterator<T>{
        private LinkedList n;
        public LIterator() {
            this.n = head;
        }
        @Override
        public boolean hasNext() {
            return n.next!=null;
        }
        @Override
        public T next() {
            n = n.next;
            return (T) n.item;
        }
    }
}

```

测试类

```java
public class SinglyListNodeTest{
    public static void main(String[] args) {
        SinglyListNode<String> head = new SinglyListNode<>();
        head.insertNode(0,"张胜男");
        head.insertNode(1,"李四");
        head.insertNode(2,"王五");
        head.insertNode(3,"6666");
        head.insertNode(4,"7777");
        for (String s : head) {
            System.out.println(s);
        }
        head.delete(0);
        String indexOf = head.getIndexOf(3);
        System.out.println(indexOf);
        for (String s : head) {
            System.out.println(s);
        }

    }
}
```



### 2、双链表

> 双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用
> 来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存
> 储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。



我们可以与单链表相同的方式访问数据：

1. 我们不能在常量级的时间内访问随机位置。
2. 我们必须从头部遍历才能得到我们想要的第一个结点。
3. 在最坏的情况下，时间复杂度将是 O(N)，其中 N 是链表的长度

#### 1、添加元素

如果我们想在现有的结点 prev 之后插入一个新的结点 cur，我们可以将此过程分为两个步骤：

1. 链接 cur 与 prev 和 next，其中 next 是 prev 原始的下一个节点；

   

2. 用 cur 重新链接 prev 和 next。



#### 2、删除链表

> 如果我们想从双链表中删除一个现有的结点 cur，我们可以简单地将它的前一个结点 prev 与下一个结点 next 链接起来。
>
> 与单链表不同，使用“prev”字段可以很容易地在常量时间内获得前一个结点。
>
> 因为我们不再需要遍历链表来获取前一个结点，所以时间和空间复杂度都是O(1)。



我们的目标是从双链表中删除结点 6。

因此，我们将它的前一个结点 23 和下一个结点 15 链接起来：



#### 3、代码实现

```java
package com.xiaobear.LinkedList;

import java.util.Iterator;

/**
 * @Author xiaobear
 * @date 2021年07月27日 14:11
 * @Description 双向链表
 */
public class DoublyLinkedList<T> implements Iterable<T>{

    /**
     * 链表长度
     */
    private int n;

    /**
     * 头结点
     */
    private Node head;
    /**
     * 尾结点
     */
    private Node last;

    /**
     * 初始化链表
     */
    public DoublyLinkedList() {
        head = new Node(null,null,null);
        last = null;
        n = 0;
    }

    /**
     * 清空链表
     */
    public void clear(){
        head = null;
        last = null;
        n = 0;
    }

    /**
     * 链表是否为空
     * @return
     */
    public boolean isEmpty(){
        return n==0;
    }

    /**
     * 数组长度
     * @return
     */
    public int length(){
        return n;
    }

    /**
     * 插入元素t
     * @param t
     */
    public void insert(T t){
        if (last==null){
            last = new Node(t,head,null);
            head.next = last;
        }else{
            Node oldLast = last;
            Node node = new Node(t, oldLast, null);
            oldLast.next = node;
            last = node;
        }
        //长度+1
        n++;
    }

    /**
     * 指定位置插入元素
     * @param i
     * @param t
     */
    public void insert(int i,T t){
        if (i < 0 || i >= n){
            throw new RuntimeException("位置不合法");
        }
        Node pre = head;
        for (int j = 0; j < i; j++) {
            pre = pre.next;
        }
        //插入位置的下一节点
        Node nextNode = pre.next;
        //初始化节点
        Node newNode = new Node(t, pre, nextNode);
       //插入节点的前一节点指向head
        nextNode.pre = newNode;
        pre.next = newNode;
        n++;

    }

    /**
     * 尾部插入元素
     * @param t
     */
    public void insertLast(T t){
        insert(n,t);
    }

    /**
     * 获取第一个元素
     * @return
     */
    public T getFirst(){
        if(isEmpty()){
            return null;
        }
        return head.next.item;
    }

    /**
     * 获取最后一个元素
     * @return
     */
    public T getLast(){
        if(isEmpty()){
            return null;
        }
        return last.item;
    }

    /**
     * 获取第i个元素的值
     * @param i
     * @return
     */
    public T getItem(int i){
        if (isEmpty()){
            return null;
        }
        Node firstNode = head.next;
        for (int j = 0; j < i; j++) {
            firstNode = firstNode.next;
        }
        return firstNode.item;
    }

    /**
     * 删除第I个元素
     * @param i
     * @return
     */
    public T remove(int i){
        Node pre = head;
        for (int j = 0; j < i; j++) {
            pre = pre.next;
        }
        //获取当前元素
        Node cur = pre.next;
        Node curNext = cur.next;
        pre.next = curNext;
        curNext.pre = pre;
        n--;
        return cur.item;
    }

    @Override
    public Iterator<T> iterator() {
        return new DIterator();
    }

    private class DIterator implements Iterator{

        private Node n = head;

        @Override
        public boolean hasNext() {
            return n.next != null;
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
        }
    }


    /**
     * 节点类
     */
    private class Node{
        //存储元素
        public T item;
        //前一节点
        public Node pre;
        //后一个节点
        public Node next;

        public Node(T item, Node pre, Node next) {
            this.item = item;
            this.pre = pre;
            this.next = next;
        }
    }
}

```

```java
public class ListNode {
  int val;
  ListNode next;
  ListNode prev;
  ListNode(int x) { val = x; }
}

class MyLinkedList {
  int size;
  // sentinel nodes as pseudo-head and pseudo-tail
  ListNode head, tail;
  public MyLinkedList() {
    size = 0;
    head = new ListNode(0);
    tail = new ListNode(0);
    head.next = tail;
    tail.prev = head;
  }

  /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */
  public int get(int index) {
    // if index is invalid
    if (index < 0 || index >= size) return -1;

    // choose the fastest way: to move from the head
    // or to move from the tail
    ListNode curr = head;
    if (index + 1 < size - index)
      for(int i = 0; i < index + 1; ++i) curr = curr.next;
    else {
      curr = tail;
      for(int i = 0; i < size - index; ++i) curr = curr.prev;
    }

    return curr.val;
  }

  /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
  public void addAtHead(int val) {
    ListNode pred = head, succ = head.next;

    ++size;
    ListNode toAdd = new ListNode(val);
    toAdd.prev = pred;
    toAdd.next = succ;
    pred.next = toAdd;
    succ.prev = toAdd;
  }

  /** Append a node of value val to the last element of the linked list. */
  public void addAtTail(int val) {
    ListNode succ = tail, pred = tail.prev;

    ++size;
    ListNode toAdd = new ListNode(val);
    toAdd.prev = pred;
    toAdd.next = succ;
    pred.next = toAdd;
    succ.prev = toAdd;
  }

  /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
  public void addAtIndex(int index, int val) {
    // If index is greater than the length, 
    // the node will not be inserted.
    if (index > size) return;

    // [so weird] If index is negative, 
    // the node will be inserted at the head of the list.
    if (index < 0) index = 0;

    // find predecessor and successor of the node to be added
    ListNode pred, succ;
    if (index < size - index) {
      pred = head;
      for(int i = 0; i < index; ++i) pred = pred.next;
      succ = pred.next;
    }
    else {
      succ = tail;
      for (int i = 0; i < size - index; ++i) succ = succ.prev;
      pred = succ.prev;
    }

    // insertion itself
    ++size;
    ListNode toAdd = new ListNode(val);
    toAdd.prev = pred;
    toAdd.next = succ;
    pred.next = toAdd;
    succ.prev = toAdd;
  }

  /** Delete the index-th node in the linked list, if the index is valid. */
  public void deleteAtIndex(int index) {
    // if the index is invalid, do nothing
    if (index < 0 || index >= size) return;

    // find predecessor and successor of the node to be deleted
    ListNode pred, succ;
    if (index < size - index) {
      pred = head;
      for(int i = 0; i < index; ++i) pred = pred.next;
      succ = pred.next.next;
    }
    else {
      succ = tail;
      for (int i = 0; i < size - index - 1; ++i) succ = succ.prev;
      pred = succ.prev.prev;
    }

    // delete pred.next 
    --size;
    pred.next = succ;
    succ.prev = pred;
  }
}
```



### 3、链表反转

> 定义一个函数， 输入一个链表的头节点， 反转该链表并输出反转后链表的头节点。
>
> 原链表中数据为：1->2->3>4
>
> 反转后链表中数据为：4->3->2->1

#### 1、递归

回顾递归的模板

```java
public ListNode reverseList(ListNode head){
    if(终止条件){
        return;
    }
    //逻辑处理
    //递归调用
    ListNode temp = reverseList(参数);
    //逻辑处理
}
```

*终止条件：链表为空或者链表没有尾节点的时候*

```java
if(head == null || head.next == null){
    return head;
}
```

*怎样递归调用：从当前节点的下一节点开始递归*

*逻辑处理：把当前节点挂在递归之后的链表的末尾*



```java
    /**
     * 链表反转
     */
    public void reverse(){
        if(null == head){
            return;
        }
        //从下一节点开始
        reverseList(head.next);
    }

    /**
     * 链表反转
     * @param curr
     * @return
     */
    public LinkedList reverseList(LinkedList curr){
        //如果链表的下一节点为空
        if(null == curr.next){
            head.next = curr;
            return curr;
        }
        //当前节点的上一个节点
        LinkedList pre = reverseList(curr.next);
        pre.next = curr;
        //当前节点的下一节点指向null
        curr.next = null;
        //返回当前节点
        return curr;
    }
```

第二种：

```java
public ListNode reverseList(ListNode head){
    if(null == head || null ==head.next){
        return head;
    }
    //保存当前节点的下一节点
    ListNode temp = head.next;
    //开始递归调用,reverse就是反转之后的链表，不包括头结点
    ListNode reverse = reverseList(temp);
    //将头结点挂在当前节点的后面
    temp.next = head;
    //反转之后头节点变成尾节点了，下一节点为空
    head.next = null;
    return reverse;
}
```

因为递归调用之后h e a d . n e x t 节点就会成为r e v e r s e 节点的尾结点， 我们可以直接让h e a d . n e x t . n e x t = h e a d ; ， 这样代码会更简洁一些。

```java
public ListNode reverse(ListNode head){
    if(null == head || null ==head.next){
        return head;
    }
    ListNode reverse = reverse(head.next);
    head.next.next = head;
    head.next = null;
    return reverse;
}
```

> 这种递归往下传递的时候基本上没有逻辑处理， 当往回反弹的时候才开始处理， 也就是从链表的尾端往前开始处理的。我们还可以再来改一下， 在链表递归的时候从前往后处理， 处理完之后直接返回递归的结果， 这就是所谓的尾递归， 这种运行效率要比上一种好很多。

```java
public ListNode reverseList(ListNode head){
    return reverseListEnd(head, null);
}
public ListNode reverseListEnd(ListNode head, ListNode newNode){
    if(head == null){
        return newNode;
    }
    //当前节点的下一节点
    ListNode next = head.next;
    head.next = newNode;
    ListNode node = reverseListEnd(next,head);
    return node;
}
```

#### 2、双链表

> 双链表求解是把原链表的结点一个个摘掉， 每次摘掉的链表都让它成为新的链表的头结点， 然后更新新链表。





```java
public ListNode reverseList(ListNode head){
    //初始化新链表
    ListNode result = null;
    while(head != null){
        //保存当前节点的下一节点
        ListNode temp = head.next;
        //每次访问的原链表节点都会成为新链表的头结点
        head.next = result;
        //更新新链表
        result = head;
        //重新赋值
        head = temp;
    }
    return result;
}
```

#### 3、栈

> 栈的原理：先进后出
>
> 实现原理就是把链表节点一个个入栈， 当全部入栈完之后再一个个出栈， 出栈的时候在把出栈的结点串成一个新的链表。



```java
public LinkedList reverseListByStack(ListNode head){
    Stack<LinkedList> stack = new Stack<>();
    while (head != null){
        //链表入栈
        stack.push(head);
        head = head.next; 
    }
    if(stack.isEmpty()){
        return null;
    }
    //栈中元素出栈
    LinkedList pop = stack.pop();
    LinkedList result = pop;
    while (!stack.isEmpty()){
        LinkedList pop1 = stack.pop();
        pop.next = pop1;
        pop = pop.next;
    }
    //最后一个结点就是反转前的头结点，一定要让他的next等于空，否则会构成环
    pop.next =null;
    return result;
}
```

### 4、快慢指针

> 快慢指针指的是定义两个指针，这两个指针的移动速度一块一慢，以此来制造出自己想要的差值，这个差值可以然我们找到链表上相应的结点。一般情况下，快指针的移动步长为慢指针的两倍

#### 1、中间值问题

> 找到链表的中间元素并返回
>
> 利用快慢指针，我们把一个链表看成一个跑道，假设a的速度是b的两倍，那么当a跑完全程后，b刚好跑一半，以此来达到找到中间节点的目的。



```java
public class FastAndSlowPointer {
    public static void main(String[] args) {
        Node<String> aa = new Node<>("aa", null);
        Node<String> bb = new Node<>("bb", null);
        Node<String> cc = new Node<>("cc", null);
        Node<String> dd = new Node<>("dd", null);
        Node<String> ee = new Node<>("ee", null);
        Node<String> ff = new Node<>("ff", null);
        Node<String> gg = new Node<>("gg", null);

        aa.next = bb;
        bb.next = cc;
        cc.next = dd;
        dd.next = ee;
        ee.next = ff;
        ff.next = gg;

        System.out.println("链表的中间元素为："+getMiddle(aa));
    }

    /**
     * 寻找链表的中间元素
     * @param first 链表的头结点
     * @return 链表中间节点的值
     */
    public static String getMiddle(Node<String> first){
        //定义两个指针分别等于first
        Node<String> fast = first;
        Node<String> slow = first;
        while(null != fast && null != fast.next){
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow.item;
    }

    public static class Node<T>{
        T item;
        Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }
}
```

*方法代码：*

```java
/**
     * 寻找链表的中间元素
     * @param first 链表的头结点
     * @return 链表中间节点的值
     */
public String getMiddle(Node<String> first){
    //定义两个指针分别等于first
    Node<String> fast = first;
    Node<String> slow = first;
    while(null != fast && null != fast.next){
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow.item;
}
```

#### 2、单向链表是否有环



> - 使用快慢指针的思想，还是把链表比作一条跑道，链表中有环，那么这条跑道就是一条圆环跑道，在一条圆环跑道中，两个人有速度差，那么迟早两个人会相遇，只要相遇那么就说明有环。
> - 使用哈希表，将链表的值存入Set中，如果有存在相同元素的，就说明有环

- 快慢指针

```java
/**
     * 判断链表是否有环--快慢指针
     * @param first 链表的头结点
     * @return
     */
public static boolean isCircle(Node<String> first){
    //定义两个指针分别等于first
    Node<String> fast = first;
    Node<String> slow = first;
    while(null != first && null != first.next){
        fast = fast.next.next;
        slow = slow.next;
        if(fast.equals(slow)){
            return true;
        }
    }
    return false;
}
```

- 哈希表

```java
/**
     *
     * @param first
     * @return
     */
public static boolean isCircleBySet(Node<String> first){
    Set<String> strings = new HashSet<>();
    while(null !=first){
        //将值存入set集合中
        if(!strings.add(first.item)){
            return true;
        }
        first = first.next;
    }
    return false;
}
```

#### 3、有环链表入口问题

> 当快慢指针相遇时，我们可以判断到链表中有环，这时重新设定一个新指针指向链表的起点，且步长与慢指针一样为1，则慢指针与“新”指针相遇的地方就是环的入口



```java
/**
     * 寻找有环链表的入口
     * @param first
     * @return
     */
public String getEntrance(Node<String> first){
    //定义两个指针分别等于first
    Node<String> fast = first;
    Node<String> slow = first;
    //新节点
    Node<String> temp = null;
    while(null != first && null != first.next){
        fast = fast.next.next;
        slow = slow.next;
        //快慢指针相遇，初始化新节点，接着遍历
        if(fast.equals(slow)){
            temp = first;
            continue;
        }
        if(null != temp){
            temp = temp.next;
            if(temp.equals(slow)){
                return temp.item;
            }
        }
    }
    return null;
}
```



### 5、循环链表

> 循环链表，顾名思义，链表整体要形成一个圆环状。在单向链表中，最后一个节点的指针为null，不指向任何结点，因为没有下一个元素了。要实现循环链表，我们只需要让单向链表的最后一个节点的指针指向头结点即可。



### 6、约瑟夫问题

> 传说有这样一个故事，在罗马人占领乔塔帕特后，39 个犹太人与约瑟夫及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，第一个人从1开始报数，依次往后，如果有人报数到3，那么这个人就必须自杀，然后再由他的下一个人重新从1开始报数，直到所有人都自杀身亡为止。然而约瑟夫和他的朋友并不想遵从。于是，约瑟夫要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，从而逃过了这场死亡游戏 。

*问题转换：*

> 41个人坐一圈，第一个人编号为1，第二个人编号为2，第n个人编号为n。
> 1.编号为1的人开始从1报数，依次向后，报数为3的那个人退出圈；
> 2.自退出那个人开始的下一个人再次从1开始报数，以此类推；
> 3.求出最后退出的那个人的编号。



*解题思路：*

> 1. 构建含有41个结点的单向循环链表，分别存储1~41的值，分别代表这41个人；
> 2. 使用计数器count，记录当前报数的值；
> 3. 遍历链表，每循环一次，count++；
> 4. 判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count重置为0；

```java
public class JosephQuestion {
    public static void main(String[] args) {
        //先构建循环链表
        Node<Integer> first = null;
        //记录当前节点的值
        Node<Integer> pre = null;
        for (int i = 1; i <= 41; i++) {
            //如果是第一个节点
            if(1 == i){
                first = new Node<>(i,null);
                pre = first;
                continue;
            }
            Node node = new Node(i, null);
            pre.next = node;
            //重置pre
            pre = node;
            //构建循环链表，让最后一个结点指向第一个结点
            if (41 == i){
                pre.next = first;
            }
        }
        //记录当前的报数值
        int count = 0;
        Node<Integer> head = first;
        //记录当前节点
        Node<Integer> temp = null;
        while (head != head.next){
            count++;
            if(3 == count){
                //判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count重置为0；
                temp.next = head.next;
                System.out.print(head.item+",");
                count = 0;
            }else {
                temp = head;
            }
            head = head.next;
        }
        System.out.println(head.item);
    }

    public static class Node<T>{
        T item;
        Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }
}
```



## 3、栈

> 栈是一种基于先进后出(FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。
>
> 我们称数据进入到栈的动作为压栈，数据从栈中出去的动作为弹栈。



### 1、栈的API设计

| 类名     | Stack                                                        |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Stack：创建Stack对象                                         |
| 成员方法 | 1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false<br/>2.public int size():获取栈中元素的个数<br/>3.public T pop():弹出栈顶元素<br/>4.public void push(T t)：向栈中压入元素t |
| 成员变量 | private Node head:记录首结点<br/>private int N:当前栈的元素个数 |

```java
public class Stack<T> implements Iterable<T>{
    /**
     *   栈长度
     */
    private int size;

    /**
     * 头结点
     */
    private Node head;

    public Stack() {
        head = new Node(null,null);
        size = 0;
    }

    public boolean isEmpty(){
        return size == 0;
    }

    public int size(){
        return size;
    }

    /**
     * 数据入栈
     * @param t
     */
    public void push(T t){
        Node next = head.next;
        //新节点
        Node newNode = new Node(t, next);
        //重新赋值
        head.next = newNode;
        size++;
    }

    /**
     * 数据出栈
     * @return
     */
    public T pop(){
        Node next = head.next;
        if(null == next){
            return null;
        }
        head.next = head.next.next;
        size--;
        return next.item;
    }

    @Override
    public Iterator<T> iterator() {
        return new SIterator();
    }

    private class SIterator implements Iterator<T>{
        private Node n = head;
        @Override
        public boolean hasNext() {
            return n.next!=null;
        }
        @Override
        public T next() {
            Node node = n.next;
            n = n.next;
            return node.item;
        }
    }

    private class Node{
        public T item;
        public Node next;
        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }
}
```

### 2、括号匹配问题

> 给定一个字符串，里边可能包含"()"小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。
> 例如：
> "(上海)(长安)"：正确匹配
> "上海((长安))"：正确匹配
> "上海(长安(北京)(深圳)南京)":正确匹配
> "上海(长安))"：错误匹配
> "((上海)长安"：错误匹配

步骤：

1. 创建一个栈用来存储左括号
2. 从左往右遍历字符串，拿到每一个字符
3. 判断该字符是不是左括号，如果是，放入栈中存储
4. 判断该字符是不是右括号，如果不是，继续下一次循环
5. 如果该字符是右括号，则从栈中弹出一个元素t；
6. 判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号
7. 循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配



```java
/**
     * 左括号入栈，右括号出栈
     * @param str
     * @return
     */
public boolean isMatch(String str){
    //创建一个栈存储左括号
    Stack<String> stack = new Stack<>();
    for (int i = 0; i < str.length(); i++) {
        
        if(s.equals("(")){
            stack.push(s);
        }else if(s.equals(")")){
            String pop = stack.pop();
            if (pop == null) {
                return false;
            }
        }
    }
    //栈中元素是否为空
    if(stack.size == 0){
        return true;
    }
    return false;
}
```

### 3、逆波兰表达式

> 中缀表达式就是我们平常生活中使用的表达式，例如：1+32,2-(1+3)等等*
>
> 中缀表达式的特点是：二元运算符总是置于两个操作数中间

逆波兰表达式(后缀表达式)：

> 逆波兰表达式是波兰逻辑学家J・卢卡西维兹(J・ Lukasewicz)于19 29年首先提出的一种表达式的表示方法，后缀表达式的特点：运算符总是放在跟它相关的操作数之后。



给定一个只包含加减乘除四种运算的逆波兰表达式的数组表示方式，求出该逆波兰表达式的结果

```java
/**
     * 求逆波兰表达式
     * @param number
     * @return
     */
public int caculate(String[] number){
    Stack<Integer> stack = new Stack<>();
    for (int i = 0; i < number.length; i++) {
        String s = number[i];
        Integer pop;
        Integer pop1;
        Integer temp;
        if("+".equals(s)){
            pop = stack.pop();
            pop1 = stack.pop();
            temp = pop + pop1;
            stack.push(temp);
        }else if("-".equals(s)){
            pop = stack.pop();
            pop1 = stack.pop();
            temp = pop1 - pop;
            stack.push(temp);
        }else if("*".equals(s)){
            pop = stack.pop();
            pop1 = stack.pop();
            temp = pop1 * pop;
            stack.push(temp);
        }else if("/".equals(s)){
            pop = stack.pop();
            pop1 = stack.pop();
            temp = pop1 / pop;
            stack.push(temp);
        }else {
            stack.push(Integer.parseInt(s));
        }
    }
    return stack.pop();
}
```



## 4、队列

> 队列是一种基于先进先出(FIFO)的数据结构，是一种只能在一端进行插入,在另一端进行删除操作的特殊线性表，它按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。



### 1、队列的API设计

| 类名     | Queue                                                        |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Queue()：创建Queue对象                                       |
| 成员方法 | 1.public boolean isEmpty()：判断队列是否为空，是返回true，否返回false<br/>2.public int size():获取队列中元素的个数<br/>3.public T dequeue():从队列中拿出一个元素<br/>4.public void enqueue(T t)：往队列中插入一个元素 |
| 成员变量 | 1.private Node head:记录首结点<br/>2.private int N:当前栈的元素个数<br/>3.private Node last:记录最后一个结点 |

```java
public class Queue<T> implements Iterable<T>{

    private int size;

    private Node head;

    private Node last;

    public Queue() {
        size = 0;
        head = new Node(null,null);
        last = null;
    }

    public boolean isEmpty(){
        return size == 0;
    }

    public int size(){
        return size;
    }

    /**
     * 插入元素到队列
     * @param t
     */
    public void enqueue(T t){
        //如果链尾都为空
        if(null == last){
            last = new Node(t,null);
            head.next = last;
        }else {
            //如果链尾不为空
            Node pre = last;
            last = new Node(t, null);
            pre.next = last;
        }
        size++;
    }

    /**
     * 取出元素
     * @return
     */
    public T dequeue(){
        if (isEmpty()){
            return null;
        }
        Node oldHead = head.next;
        head.next = oldHead.next;
        size--;
        if (isEmpty()){
            last = null;
        }
        return oldHead.item;
    }

    /**
     * 节点类
     */
    private class Node{
        public T item;
        public Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }

    @Override
    public Iterator<T> iterator() {
        return new QIterator();
    }

    public class QIterator implements Iterator<T>{

        private Node n = head;

        @Override
        public boolean hasNext() {
            return n.next != null;
        }

        @Override
        public T next() {
            Node node = n.next;
            n = n.next;
            return node.item;
        }
    }
}
```



# 6、符号表

> 符号表最主要的目的就是将一个键和一个值联系起来，符号表能够将存储的数据元素是一个键和一个值共同组成的键值对数据，我们可以根据键来查找对应的值。
>
> 符号表中，键具有唯一性。



符号表的应用：

| 应用     | 查找目的                 | 键     | 值       |
| -------- | ------------------------ | ------ | -------- |
| 字典     | 找出单词的释义           | 单词   | 释义     |
| 图书索引 | 找出某个术语相关的页码   | 术语   | 一串页码 |
| 网络搜索 | 找出某个关键字对应的网页 | 关键字 | 网页名称 |

## 1、符号表的API设计

- 节点类

  | 类名     | Node<Key,Value>                                              |
  | -------- | ------------------------------------------------------------ |
  | 构造方法 | Node(Key key,Value value,Node next)：创建Node对象            |
  | 成员变量 | 1.public Key key:存储键<br/>2.public Value value:存储值<br/>3.public Node next:存储下一个结点 |

- 符号表

  | 类名     | SymbolTable<Key,Value>                                       |
  | -------- | ------------------------------------------------------------ |
  | 构造方法 | SymbolTable()：创建SymbolTable对象                           |
  | 成员方法 | 1.public Value get(Key key)：根据键key，找对应的值<br/>2.public void put(Key key,Value val):向符号表中插入一个键值对<br/>3.public void delete(Key key):删除键为key的键值对<br/>4.public int size()：获取符号表的大小 |
  | 成员变量 | 1.private Node head:记录首结点<br/>2.private int N:记录符号表中键值对的个数 |

  

```java
public class SymbolTable<Key,Value> {
    //头结点
    private Node head;
    //长度
    private int size;


    public SymbolTable() {
        head = new Node(null,null,null);
        size = 0;
    }

    /**
     * ：根据键key，找对应的值
     * @param key
     * @return
     */
    public Value get(Key key){
        Node<Key,Value> n = head;
        while(n.next != null){
            n = n.next;
            if(n.key.equals(key)){
                return n.value;
            }
        }
        return null;
    }

    /**
     * 向符号表中插入一个键值对
     * @param key
     * @param val
     */
    public void put(Key key,Value val){
        Node<Key,Value> pre = head;
        while(pre.next != null){
            pre = pre.next;
            if(pre.key.equals(key)){
                pre.value = val;
                return;
            }
        }
        Node oldFirst = head.next;
        Node<Key, Value> node = new Node<>(key, val, oldFirst);
        head.next = node;
        size++;
    }

    /**
     * 删除键为key的键值对<br/>
     * @param key
     */
    public void delete(Key key){
        Node n = head;
        while(null != n.next){
            if(n.next.key.equals(key)){
                n.next = n.next.next;
                size--;
                return;
            }
            n = n.next;
        }
    }

    /**
     * 获取符号表的大小
     * @return
     */
    public int size(){
       return size;
    }


    private class Node<Key,Value>{
        Key key;
        Value value;
        Node next;

        public Node(Key key, Value value, Node next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }
}
```

## 2、有序符号表

> 刚才实现的符号表，我们可以称之为无序符号表，因为在插入的时候，并没有考虑键值对的顺序，而在实际生活中，有时候我们需要根据键的大小进行排序，插入数据时要考虑顺序，那么接下来我们就实现一下有序符号表。

```java
package com.xiaobear.SymbolTable;

/**
 * @Author xiaobear
 * @date 2021年07月30日 10:00
 * @Description 符号表
 */
public class OrderSymbolTable<Key extends Comparable<Key>,Value> {
    //头结点
    private Node head;
    //长度
    private int size;


    public OrderSymbolTable() {
        head = new Node(null,null,null);
        size = 0;
    }

    /**
     * ：根据键key，找对应的值
     * @param key
     * @return
     */
    public Value get(Key key){
        Node<Key,Value> n = head;
        while(n.next != null){
            n = n.next;
            if(n.key.equals(key)){
                return n.value;
            }
        }
        return null;
    }

    /**
     * 向符号表中插入一个键值对
     * @param key
     * @param val
     */
    public void put(Key key,Value val){
        Node<Key,Value> curr = head.next;
        //记录上一个节点
        Node pre = head;
        //1.如果key大于当前结点的key，则一直寻找下一个结点
        while(curr!=null && key.compareTo(curr.key)>0){
            pre = curr;
            curr = curr.next;
        }
        //2.如果当前结点curr的key和将要插入的key一样，则替换
        if (curr!=null && curr.key.compareTo(key)==0){
            curr.value = val;
            return;
        }
        //3.没有找到相同的key，把新结点插入到curr之前
        Node newNode = new Node(key, val, curr);
        pre.next = newNode;
        size++;
    }

    /**
     * 删除键为key的键值对<br/>
     * @param key
     */
    public void delete(Key key){
        Node n = head;
        while(null != n.next){
            if(n.next.key.equals(key)){
                n.next = n.next.next;
                size--;
                return;
            }
            n = n.next;
        }
    }

    /**
     * 获取符号表的大小
     * @return
     */
    public int size(){
       return size;
    }


    private class Node<Key,Value>{
        Key key;
        Value value;
        Node next;

        public Node(Key key, Value value, Node next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }
}
```



# 7、二叉树

## 1、树的相关概念

### 1、树的基本定义

> 树是我们计算机中非常重要的一种数据结构，同时使用树这种数据结构，可以描述现实生活中的很多事物，例如家谱、单位的组织架构、等等。
> 树是由n（n>=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。



*树具有以下特点：*

- 每个结点有零个或多个子结点；
- 没有父结点的结点为根结点；
- 每一个非根结点只有一个父结点；
- 每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树；

### 2、相关术语

#### 1、结点的度

> 一个结点含有的子树的个数称为该结点的度；

#### 2、叶子结点

> 度为0的结点称为叶结点，也可以叫做终端结点

#### 3、分支结点

> 度不为0的结点称为分支结点，也可以叫做非终端结点

#### 4、结点的层次

> 从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推

#### 5、结点的层序编号

> 将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。

#### 6、树的度

> 树中所有结点的度的最大值

#### 7、树的高度(深度)

> 树中结点的最大层次

#### 8、森林

> m（m>=0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根结点，森林就变成一棵树



#### 9、孩子结点

> 一个结点的直接后继结点称为该结点的孩子结点

#### 10、双亲结点(父结点)

> 一个结点的直接前驱称为该结点的双亲结点

#### 11、兄弟结点

> 同一双亲结点的孩子结点间互称兄弟结点



## 2、二叉树

> 二叉树就是度不超过2的树(每个结点最多有两个子结点) 



### 1、相关二叉树

#### 1、满二叉树

> 一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。



#### 2、完全二叉树

> 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树



### 2、创建二叉查找树

#### 1、API设计

- 结点类

  | 类名     | Node<Key,Value>                                              |
  | -------- | ------------------------------------------------------------ |
  | 构造方法 | Node(Key key, Value value, Node left, Node right)：创建Node对象 |
  | 成员变量 | 1.public Node left:记录左子结点<br/>2.public Node right:记录右子结点<br/>3.public Key key:存储键<br/>4.public Value value:存储值 |

- 二叉树

  | 类名     | BinaryTree<Key,value>                                        |
  | -------- | ------------------------------------------------------------ |
  | 构造方法 | BinaryTree()：创建BinaryTree对象                             |
  | 成员变量 | 1.private Node root:记录根结点<br/>2.private int N:记录树中元素的个数 |
  | 成员方法 | 1. public void put(Key key,Value value):向树中插入一个键值对<br/>2.private Node put(Node x, Key key, Value val)：给指定树x上，添加键一个键值对，并返回添加后的新树<br/>3.public Value get(Key key):根据key，从树中找出对应的值<br/>4.private Value get(Node x, Key key):从指定的树x中，找出key对应的值<br/>5.public void delete(Key key):根据key，删除树中对应的键值对<br/>6.private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的新树<br/>7.public int size():获取树中元素的个数 |

##### 1、put方法实现思路

> - 如果当前树中没有任何一个结点，则直接把新结点当做根结点使用
>
> - 如果当前树不为空，则从根结点开始：
>
>   - 如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；
>
>   - 如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；
>
>   - 如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。

```java
/**
     * 给指定树x上，添加键一个键值对，并返回添加后的新树
     * @param x 树节点
     * @param key 键
     * @param val 值
     * @return Node
     */
public Node<Key, Value> put(Node<Key,Value> x, Key key, Value val){
    //当树为空时，该节点为根节点
    if(null == x){
        size++;
        return new Node<>(key, val, null, null);
    }
    int compare = key.compareTo(x.key);
    //如果compare > 0 ,则 key > x.key;继续x的右子节点
    if(0 < compare){
        x.right = put(x.right,key,val);
    }else if(0 > compare){
        //如果compare < 0 ,则 key < x.key;继续x的左子节点
        x.left = put(x.left,key,val);
    }else {
        //如果compare = 0 ,则 key = x.key;替换x.value的值
        x.value = val;
    }
    return x;
}
```

##### 2、get方法实现思路

> 从根节点开始：
>
> - 如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；
> - 如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；
> - 如果要查询的key等于当前结点的key，则树中返回当前结点的value。

```java
/**
     * 从指定的树x中，找出key对应的值
     * @param x 节点
     * @param key 键
     * @return 节点
     */
public Value getNode(Node<Key,Value> x, Key key){
    if (null == x){
        return null;
    }
    int compare = key.compareTo(x.key);
    if(0 < compare){
        return getNode(x.right,key);
    }else if(0 > compare){
        return getNode(x.left, key);
    }else {
        return x.value;
    }
}
```

##### 3、delete方法的实现思路

> - 找到被删除结点；
> - 找到被删除结点右子树中的最小结点minNode
> - 删除右子树中的最小结点
> - 让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树
> - 让被删除结点的父节点指向最小结点minNode

```java
/**
     * 删除指定树x中的key对应的value，并返回删除后的新树
     * @param x
     * @param key
     * @return
     */
public Node<Key,Value> delete(Node<Key, Value> x, Key key){
    if (null == x){
        return null;
    }
    int compare = key.compareTo(x.key);
    if(0 < compare){
        x.right = delete(x.right,key);
    }else if(0 > compare){
        x.left = delete(x.left,key);
    }else {
        //个数-1
        size--;
        //新结点的key等于当前结点的key,当前x就是要删除的结点
        if(x.right == null){
            return x.left;
        }if(x.left == null){
            return x.right;
        }
        //左右子结点都存在的情况下，找右子树最小的节点
        Node<Key, Value> minRight = x.right;
        while (null != minRight.left){
            minRight = minRight.left;
        }
        Node<Key, Value> node = x.right;
        while (node.left != null) {
            if (node.left.left == null) {
                node.left = null;
            } else {
                node = node.left;
            }
        }
        //让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树
        minRight.left = x.left;
        minRight.right = x.right;
        //让被删除结点的父节点指向最小结点minNode
        x = minRight;
    }
    return x;
}
```

##### 4、完整代码

```java
package com.xiaobear.BinaryTree;

/**
 * @Author xiaobear
 * @date 2021年07月30日 13:50
 * @Description 二叉树
 */
public class BinaryTree<Key extends Comparable<Key>,Value> {

    /**
     * 根节点
     */
    private Node<Key,Value> root;
    /**
     * 节点数量
     */
    private int size;

    public void put(Key key, Value val){
        root = put(root,key,val);
    }

    /**
     * 给指定树x上，添加键一个键值对，并返回添加后的新树
     * @param x 树节点
     * @param key 键
     * @param val 值
     * @return Node
     */
    public Node<Key, Value> put(Node<Key,Value> x, Key key, Value val){
        //当树为空时，该节点为根节点
       if(null == x){
           size++;
           return new Node<>(key, val, null, null);
       }
       int compare = key.compareTo(x.key);
       //如果compare > 0 ,则 key > x.key;继续x的右子节点
        if(0 < compare){
            x.right = put(x.right,key,val);
        }else if(0 > compare){
            //如果compare < 0 ,则 key < x.key;继续x的左子节点
            x.left = put(x.left,key,val);
        }else {
            //如果compare = 0 ,则 key = x.key;替换x.value的值
            x.value = val;
        }
        return x;
    }

    /**
     * 根据key，从树中找出对应的值
     * @param key 键
     */
    public Value getNode(Key key){
        return getNode(root,key);
    }

    /**
     * 从指定的树x中，找出key对应的值
     * @param x 节点
     * @param key 键
     * @return 节点
     */
    public Value getNode(Node<Key,Value> x, Key key){
        if (null == x){
            return null;
        }
        int compare = key.compareTo(x.key);
        if(0 < compare){
            return getNode(x.right,key);
        }else if(0 > compare){
            return getNode(x.left, key);
        }else {
            return x.value;
        }
    }

    public void delete(Key key){
        root = delete(root, key);
    }

    /**
     * 删除指定树x中的key对应的value，并返回删除后的新树
     * @param x
     * @param key
     * @return
     */
    public Node<Key,Value> delete(Node<Key, Value> x, Key key){
        if (null == x){
            return null;
        }
        int compare = key.compareTo(x.key);
        if(0 < compare){
            x.right = delete(x.right,key);
        }else if(0 > compare){
            x.left = delete(x.left,key);
        }else {
            //个数-1
            size--;
            //新结点的key等于当前结点的key,当前x就是要删除的结点
            if(x.right == null){
                return x.left;
            }if(x.left == null){
                return x.right;
            }
            //左右子结点都存在的情况下，找右子树最小的节点
            Node<Key, Value> minRight = x.right;
            while (null != minRight.left){
                minRight = minRight.left;
            }
            Node<Key, Value> node = x.right;
            while (node.left != null) {
                if (node.left.left == null) {
                    node.left = null;
                } else {
                    node = node.left;
                }
            }
            //让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树
            minRight.left = x.left;
            minRight.right = x.right;
            //让被删除结点的父节点指向最小结点minNode
            x = minRight;
        }
        return x;
    }

    public int size(){
        return size;
    }



    /**
     * 节点类
     * @param <Key>
     * @param <Value>
     */
    private class Node<Key,Value>{
        public Key key;

        public Value value;

        public Node<Key,Value> left;

        public Node<Key, Value> right;

        public Node(Key key, Value value, Node left, Node<Key, Value> right) {
            this.key = key;
            this.value = value;
            this.left = left;
            this.right = right;
        }
    }
}
```

测试代码

```java
public class BinaryTreeTest {

    public static void main(String[] args) {
        BinaryTree<Integer, String> binaryTree = new BinaryTree<>();
        binaryTree.put(1,"yhx");
        binaryTree.put(2,"love");
        binaryTree.put(3,"lwh");
        System.out.println(binaryTree.size());
        binaryTree.delete(2);
        String node = binaryTree.getNode(2);
        System.out.println(node);
        System.out.println(binaryTree.size());
    }
}
```



### 3、查找二叉树中最大/最小的键

#### 1、最小的键

| 方法                     | 描述                            |
| ------------------------ | ------------------------------- |
| public Key min()         | 找出树中最小的键                |
| private Node min(Node x) | 找出指定树x中，最小键所在的结点 |

```java
/**
     * 查找树中最小的键
     * @return
     */
public Key minKey(){
    return minKey(root).key;
}

/**
     * 根据二叉树的特点，左子树 < 右子树 so最小的键肯定是位于左边
     * @param x
     * @return
     */
public Node<Key,Value> minKey(Node<Key,Value> x){
    if (x.left != null){
        return minKey(x.left);
    }else {
        return x;
    }
}
```

#### 2、最大的键

| 方法                    | 描述                            |
| ----------------------- | ------------------------------- |
| public Key max()        | 找出树中最大的键                |
| public Node max(Node x) | 找出指定树x中，最大键所在的结点 |



```java
/**
     * 查询树中最大的键
     * @return
     */
    public Key maxKey(){
        return maxKey(root).key;
    }

    /**
     * 根据二叉树的特点，右子树 > 左子树 so最大的键肯定是位于右边
     * @param x
     * @return
     */
    public Node<Key,Value> maxKey(Node<Key,Value> x){
        if(x.right != null){
            return maxKey(x.right);
        }else {
            return x;
        }
    }
```



## 3、二叉树的遍历



我们把树简单的画作上图中的样子，由一个根节点、一个左子树、一个右子树组成，那么按照根节点什么时候被访
问，我们可以把二叉树的遍历分为以下三种方式：

- 前序遍历

  > 先访问根结点，然后再访问左子树，最后访问右子树

- 中序遍历

  > 先访问左子树，中间访问根节点，最后访问右子树

- 后序遍历

  > 先访问左子树，再访问右子树，最后访问根节点



### 1、前序遍历

前序遍历的API

| 方法                                            | 描述                                              |
| ----------------------------------------------- | ------------------------------------------------- |
| public Queue<Key> preErgodic()                  | 使用前序遍历，获取整个树中的所有键                |
| private void preErgodic(Node x,Queue<Key> keys) | 使用前序遍历，把指定树x中的所有键放入到keys队列中 |

```java
/**
     * 前序遍历
     * @return
     */
public Queue<Key> preErgodic(){
    Queue<Key> queue = new Queue<>();
    preErgodic(root,queue);
    return queue;
}

/**
     * 前序遍历操作 先访问根结点，然后再访问左子树，最后访问右子树
     * @param x 根节点
     * @param queue 队列
     */
private void preErgodic(Node<Key,Value> x, Queue<Key> queue){
    if (x == null) {
        return;
    }
    //把当前结点的key放入到队列中
    queue.enqueue(x.key);
    //访问左子树
    if(x.left != null){
        preErgodic(x.left,queue);
    }
    //访问右子树
    if(x.right != null){
        preErgodic(x.right,queue);
    }
}
```



### 2、中序遍历

中序遍历的API

| 方法                                            | 描述                                              |
| ----------------------------------------------- | ------------------------------------------------- |
| public Queue<Key> midErgodic()                  | 使用中序遍历，获取整个树中的所有键                |
| private void midErgodic(Node x,Queue<Key> keys) | 使用中序遍历，把指定树x中的所有键放入到keys队列中 |

```java
/**
     * 中序遍历
     * @return
     */
    public Queue<Key> midErgodic(){
        Queue<Key> queue = new Queue<>();
        midErgodic(root,queue);
        return queue;
    }

    /**
     * 先访问左子树，中间访问根节点，最后访问右子树
     * @param x
     * @param queue
     */
    private void midErgodic(Node<Key,Value> x, Queue<Key> queue){
        if (x == null) {
            return;
        }
        //访问左子树
        if(x.left != null){
            preErgodic(x.left,queue);
        }
        //把当前结点的key放入到队列中
        queue.enqueue(x.key);
        //访问右子树
        if(x.right != null){
            preErgodic(x.right,queue);
        }
    }
```



### 3、后序遍历

后序遍历的API

| 方法                                              | 描述                                              |
| ------------------------------------------------- | ------------------------------------------------- |
| public Queue<Key> afterErgodic()                  | 使用后序遍历，获取整个树中的所有键                |
| private void afterErgodic(Node x,Queue<Key> keys) | 使用后序遍历，把指定树x中的所有键放入到keys队列中 |

```java
 /**
     * 后序遍历
     * @return
     */
    public Queue<Key> afterErgodic(){
        Queue<Key> queue = new Queue<>();
        afterErgodic(root,queue);
        return queue;
    }

    /**
     * 先访问左子树，再访问右子树，最后访问根节点
     * @param x
     * @param queue
     */
    private void afterErgodic(Node<Key,Value> x, Queue<Key> queue){
        if (x == null) {
            return;
        }
        //访问左子树
        if(x.left != null){
            preErgodic(x.left,queue);
        }
        //访问右子树
        if(x.right != null){
            preErgodic(x.right,queue);
        }
        //把当前结点的key放入到队列中
        queue.enqueue(x.key);
    }
```



### 4、测试

```java
public class BinaryTreeErgodicTest {

    public static void main(String[] args) {
        BinaryTree<String, String> bt = new BinaryTree<>();
        bt.put("E", "5");
        bt.put("B", "2");
        bt.put("G", "7");
        bt.put("A", "1");
        bt.put("D", "4");
        bt.put("F", "6");
        bt.put("H", "8");
        bt.put("C", "3");
        //前序遍历
        Queue<String> preErgodic = bt.preErgodic();
        //中序遍历
        Queue<String> midErgodic = bt.midErgodic();
        //后序遍历
        Queue<String> afterErgodic = bt.afterErgodic();
        for (String key : preErgodic) {
            System.out.println(key+"=" +bt.getNode(key));
        }
    }
}
```



## 4、层次遍历

> 所谓的层序遍历，就是从根节点（第一层）开始，依次向下，获取每一层所有结点的值



层次遍历的结果是：EBGADFHC

| 方法                               | 描述                                 |
| ---------------------------------- | ------------------------------------ |
| public Queue<Key> layerErgodic()： | 使用层序遍历，获取整个树中的所有键实 |

实现步骤：

1. 创建队列，存储每一层的结点；
2. 使用循环从队列中弹出一个结点：
   - 获取当前结点的key
   - 如果当前结点的左子结点不为空，则把左子结点放入到队列中
   - 如果当前结点的右子结点不为空，则把右子结点放入到队列中

```java
/**
     * 层次遍历
     * @return
     */
public Queue<Key> layerErgodic(){
    //存储key
    Queue<Key> keys = new Queue<>();
    //存储node
    Queue<Node<Key,Value>> nodes = new Queue<>();
    //入队头结点
    nodes.enqueue(root);
    while(!nodes.isEmpty()){
        //出队当前节点
        Node<Key,Value> dequeue = nodes.dequeue();
        //当前节点头入队
        keys.enqueue(dequeue.key);
        if(dequeue.left != null){
            nodes.enqueue(dequeue.left);
        }
        if(dequeue.right != null){
            nodes.enqueue(dequeue.right);
        }
    }
    return keys;
}
```



## 5、二叉树的最大深度

> 最大深度（树的根节点到最远叶子结点的最长路径上的结点数）



上面这颗树的最大深度为：E–>B–>D–>C，深度为4

| 方法                         | 描述                  |
| ---------------------------- | --------------------- |
| public int maxDepth()        | 计算整棵树的最大深度  |
| private int maxDepth(Node x) | 计算指定树x的最大深度 |

*实现步骤：*

1. 如果根结点为空，则最大深度为0；
2. 计算左子树的最大深度；
3. 计算右子树的最大深度；
4. 当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1

```java
    /**
     * 计算整棵树的最大深度
     * @return
     */
    public int maxDepth(){
        return maxDepth(root);
    }

    /**
     * 计算指定节点的最大深度
     * @param x
     * @return
     */
    private int maxDepth(Node<Key,Value> x){
        if (x == null) {
            return 0;
        }
        int maxRight = 0;
        int maxLeft = 0;
        int maxDepth;
        if(x.left != null){
            maxLeft = maxDepth(x.left);
        }
        if (x.right != null) {
            maxRight = maxDepth(x.right);
        }
        maxDepth = maxLeft > maxRight ? maxLeft + 1 : maxRight + 1;
        return maxDepth;
    }
```



## 6、折纸问题

> 请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时 折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2 次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。
> 给定一 个输入参数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕的方向 例如：N=1时，打印： down；N=2时，打印： down down up



### 分析

> 我们把对折后的纸张翻过来，让粉色朝下，这时把第一次对折产生的折痕看做是根结点，那第二次对折产生的下折痕就是该结点的左子结点，而第二次对折产生的上折痕就是该结点的右子结点，这样我们就可以使用树型数据结构来描述对折后产生的折痕。

这棵树有这样的特点：

1. 根结点为下折痕；
2. 每一个结点的左子结点为下折痕；
3. 每一个结点的右子结点为上折痕；



实现步骤：

- 构建节点类
- 构建深度为n的折痕树
- 使用中序遍历，打印树中所有节点的内容

构建深度为N的折痕树：

1. 第一次对折，只有一条折痕，创建根节点
2. 如果不是第一次对折，则使用队列保存根节点
3. 循环遍历队列
   - 从队列中拿出一个节点
   - 如果当前节点的左节点不为空，则把这个左节点加入队列中
   - 如果当前节点的右节点不为空，则把这个右节点加入队列中
   - 判断当前结点的左子结点和右子结点都为空，如果是，则需要为当前结点创建一个值为down的左子结点，一个值为up的右子结点。



```java
public class PaperFolding {

    /**
     * 创建折痕树
     * @param size 深度
     */
    public static Node createTree(int size){
        Node root = null;
        for (int i = 0; i < size; i++) {
            //第一次对折，只有一条折痕，创建根节点
            if (0 == i){
                root = new Node("down",null,null);
            }else {
                //如果不是第一次对折，则使用队列保存根节点
                Queue<Node> nodes = new Queue<>();
                nodes.enqueue(root);
                //循环遍历
                while(!nodes.isEmpty()){
                    //从队列中拿出一个节点
                    Node dequeue = nodes.dequeue();
                    //如果当前节点的左节点不为空，则把这个左节点加入队列中
                    if(dequeue.left != null){
                        nodes.enqueue(dequeue.left);
                    }
                    //如果当前节点的右节点不为空，则把这个右节点加入队列中
                    if(dequeue.right != null){
                        nodes.enqueue(dequeue.right);
                    }
                    //判断当前结点的左子结点和右子结点都为空，则需要为当前结点创建一个值为down的左子结点，一个值为up的右子结点。
                    if(dequeue.left == null && dequeue.right == null){
                        dequeue.left = new Node("down",null,null);
                        dequeue.right = new Node("up",null,null);
                    }
                }
            }
        }
        return root;
    }

    /**
     * 采用中序遍历
     * @param root
     */
    public static void printTree(Node root){
        if (root == null) {
            return;
        }
        printTree(root.left);
        System.out.print(root.item+" ");
        printTree(root.right);
    }

    /**
     * 节点类
     */
    private static class Node{
        String item;
        Node left;
        Node right;

        public Node(String item, Node left, Node right) {
            this.item = item;
            this.left = left;
            this.right = right;
        }
    }

    public static void main(String[] args) {
        Node tree = createTree(2);
        printTree(tree);
    }
}
```

```
down down up 
```



# 8、堆

## 1、堆的定义

> 堆是计算机科学中一类特殊的数据结构的统称，堆通常可以被看做是一棵完全二叉树的数组对象。

### 1、堆的特性

1. 它是完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求左满右不满。

   

2. 它是由数组实现的。就是将二叉树的结点按层级顺序放入数组中，根节点在位置1，它的子节点在2和3，以此类推；

   > 如果一个节点的位置为k，则它的父节点的位置为k/2，而它的两个子节点的位置分别为2k和2k+1
   >
   > 我们可以通过计算数组的索引在树中上下移动，从a[k]向上一层，就令 k = k/2，向下一层就令k = 2k/ k = 2k+1

   

3. 每个节点都大于等于它的两个子节点

   > ps：这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的。



## 2、堆的设计

### 1、API设计

| 类名     | Heap<>                                                       |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Heap(int capacity)：创建容量为capacity的Heap对象             |
| 成员方法 | private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br>private void exch(int i,int j):交换堆中i索引和j索引处的值<br>public T delMax():删除堆中最大的元素,并返回这个最大元素<br>public void insert(T t)：往堆中插入一个元素<br>private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br>private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 |
| 成员变量 | private T[] items : 用来存储元素的数组<br>private int N：记录堆中元素的个数 |

### 2、插入方法实现

> 堆是用数组完成数据的存储的，由于数组的底层是一串连续的内存地址，所以我们要往堆中插入数据，我们只能往数组中从索引0处开始，依次往后存放数据，但是堆中对元素的顺序是有要求的，每一个结点的数据要大于等于它的两个子结点的数据，所以每次插入一个元素，都会使得堆中的数据顺序变乱，这个时候我们就需要通过一些方法让刚才插入的这个数据放入到合适的位置。



*总结：如果往堆中新插入元素，我们只需要不断的比较新结点a[k]和它的父结点a[k/2]的大小，然后根据结果完成数据元素的交换，就可以完成堆的有序调整。*

### 3、删除方法实现

> 由堆的特性我们可以知道，索引1处的元素，也就是根结点就是最大的元素，当我们把根结点的元素删除后，需要有一个新的根结点出现，这时我们可以暂时把堆中最后一个元素放到索引1处，充当根结点，但是它有可能不满足堆的有序性需求，这个时候我们就需要通过一些方法，让这个新的根结点放入到合适的位置。



*总结：当删除掉最大元素后，只需要将最后一个元素放到索引1处，并不断的拿着当前结点a[k]与它的子结点a[2k]和a[2k+1]中的较大者交换位置，即可完成堆的有序调整。*

### 4、完整代码

```java
public class Heap<T extends Comparable<T>> {

    /**
     * 存储元素
     */
    private T[] items;

    /**
     * 堆元素个数
     */
    private int size;

    public Heap(int capacity){
        items = (T[]) new Comparable[capacity];
        size = 0;
    }

    /**
     * 判断堆中索引i的值是否小于索引j处的值
     * @param i
     * @param j
     * @return
     */
    private boolean less(int i, int j){
        return items[i].compareTo(items[j]) < 0;
    }

    /**
     * 交换索引i和索引j的值
     * @param i
     * @param j
     */
    private void each(int i, int j){
        T temp = items[i];
        items[i] = items[j];
        items[j] = temp;
    }

    /**
     * 插入一个元素
     * @param t
     */
    public void insert(T t){
        items[++size] = t;
        //上浮，重新排序
        swim(size);
    }

    /**
     * 上浮算法，使索引k处的元素能在堆中处于一个正确的位置
     * @param k
     */
    public void swim(int k){
        //从叶子节点往上面循环，到根节点就结束循环
        while (1 < k){
            //比较当前节点与父节点
            if(less(k/2, 2)){
                //父结点小于当前结点，需要交换
                each(k/2,k);
            }
            k = k/2;
        }
    }

    /**
     * 删除堆中最大的元素
     * @return max
     */
    public T delMax(){
        //获取最大元素
        T max = items[1];
        //交换索引1处和索引size处的值
        each(1,size);
        //交换后置null
        items[size] = null;
        size--;
        //将索引1的值下沉
        sink(1);
        return max;
    }

    /**
     * 下沉算法，使索引k的元素位于堆中一个正确的位置
     * @param k
     */
    private void sink(int k){
        //如果到底层就结束循环 2*k > size
        while(2*k <= size){
            int max;
            //是否存在右子节点
            if(2*k + 1 <= size){
                //
                if (less(2*k,2*k+1)){
                    max = 2*k + 1;
                }else {
                    max = 2*k;
                }
            }else { //不存在右节点
                max = 2*k;
            }
            //比较当前结点和子结点中的较大者，如果当前结点不小，则结束循环
            if(!less(k,max)){
                break;
            }
            each(k, max);
            k = max;
        }
    }
}
```

测试类

```java
public class HeapTest {

    public static void main(String[] args){
        Heap<String> heap = new Heap<String>(20);
        heap.insert("S");
        heap.insert("G");
        heap.insert("I");
        heap.insert("E");
        heap.insert("N");
        heap.insert("H");
        heap.insert("O");
        heap.insert("A");
        heap.insert("T");
        heap.insert("P");
        heap.insert("R");
        String del;
        while ((del= heap.delMax()) != null){
            System.out.print(del + " ");
        }
    }
}
```



## 3、堆排序

> 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。

```java
String[] arr = {"S","O","R","T","E","X","A","M","P","L","E"};
```

实现步骤

1. 构造堆
2. 获取堆顶元素，这就是最大值
3. 交换堆顶元素和数组中的最后一个元素，此时所有元素中的最大元素已经放到合适位置
4. 对堆进行调整，重新让除了最后一个元素的剩余元素中的最大值放到堆顶
5. 重复2-4步骤，直到堆中剩一个元素为止



API设计

| 类名     | HeapSort                                                     |
| -------- | ------------------------------------------------------------ |
| 成员方法 | public static void sort(Comparable[] source)：对source数组中的数据从小到大排序<br>private static void createHeap(Comparable[] source, Comparable[] heap):根据原数组source，构造出堆heap<br>private static boolean less(Comparable[] heap, int i, int j)：判断heap堆中索引i处的元素是否小于索引j处的元素<br>private static void exch(Comparable[] heap, int i, int j):交换heap堆中i索引和j索引处的值<br>private static void sink(Comparable[] heap, int target, int range):在heap堆中，对target处的元素做下沉，范围是0~range。 |



### 1、堆构造过程

> 堆的构造，最直观的想法就是另外再创建一个和新数组数组，然后从左往右遍历原数组，每得到一个元素后，添加
> 到新数组中，并通过上浮，对堆进行调整，最后新的数组就是一个堆。
> 上述的方式虽然很直观，也很简单，但是我们可以用更聪明一点的办法完成它。创建一个新数组，把原数组0到length-1的数据拷贝到新数组的1~length处，再从新数组长度的一半处开始往1索引处扫描（从右往左），然后对扫描到的每一个元素做下沉调整即可。



### 2、堆排序过程

对构造好的堆，我们只需要做类似于堆的删除操作，就可以完成排序。

1. 将堆顶元素和堆中最后一个元素交换位置；
2. 通过对堆顶元素下沉调整堆，把最大的元素放到堆顶(此时最后一个元素不参与堆的调整，因为最大的数据已经到了数组的最右边)
3. 重复1~2步骤，直到堆中剩最后一个元素。



### 3、完整代码

```java
public class HeapSort {

    /**
     * 判断堆中索引i处的值是否小于索引j的值
     * @param heap 堆
     * @param i 索引i
     * @param j 索引j
     * @return true or false
     */
    private static boolean less(Comparable[] heap, int i, int j){
        return heap[i].compareTo(heap[j]) < 0;
    }

    /**
     * 交换索引i和索引j处的值
     * @param heap
     * @param i
     * @param j
     */
    private static void swap(Comparable[] heap, int i, int j){
        Comparable temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }

    /**
     * 根据原数组source，构造出堆heap
     * @param source 原数组
     * @param heap 目标数组
     */
    private static void createHeap(Comparable[] source, Comparable[] heap){
        //把source中的数据拷贝到heap中，从heap的1索引处开始填充
        System.arraycopy(source,0,heap,1,source.length);
        //从heap索引的一半处开始倒叙遍历，对得到的每一个元素做下沉操作
        for (int i = (heap.length - 1) / 2; i > 0; i--) {
            sink(heap,i, heap.length - 1);
        }
    }

    /**
     * 对source数组中从小到大排序
     * @param source
     */
    public static void sort(Comparable[] source){
        //创建一个比原数组大1的数组
        Comparable[] heap = new Comparable[source.length + 1];
        //创造堆
        createHeap(source,heap);
        int n = heap.length - 1;
        while (1 != n){
            //交换heap中索引1处的元素和N处的元素
            swap(heap, 1, n);
            n--;
            //对索引1处的元素在0~N范围内做下沉操作
            sink(heap, 1, n);
        }
        //heap中的数据已经有序，拷贝到source中
        System.arraycopy(heap,1,source,0,source.length);

    }

    /**
     * 在heap堆中，对target处的元素做下沉，范围是0~range。
     * @param heap 堆
     * @param target 索引
     * @param range 范围
     */
    private static void sink(Comparable[] heap, int target, int range){
        //没有子节点 退出循环
        while (2 * target <= range){
            //找出target结点的两个子结点中的较大值
            int max = 2*target;
            if(2 * target + 1 <= range){
                if (less(heap,2*target,2*target+1)){
                    max = 2 * target + 1;
                }
            }
            //如果当前结点的值小于子结点中的较大值，则交换
            if(less(heap,target,max)){
                swap(heap, target, max);
            }
            //更新target的值
            target = max;
        }
    }

    public static void main(String[] args) {
        String[] arr = {"S", "O", "R", "T", "E", "X", "A", "M", "P", "L", "E"};
        HeapSort.sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
```



# 9、优先队列

> 普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在某些情况下，我们可能需要找出队列中的最大值或者最小值，例如使用一个队列保存计算机的任务，一般情况下计算机的任务都是有优先级的，我们需要在这些计算机的任务中找出优先级最高的任务先执行，执行完毕后就需要把这个任务从队列中移除。普通的队列要完成这样的功能，需要每次遍历队列中的所有元素，比较并找出最大值，效率不是很高，这个时候，我们就可以使用一种特殊的队列来完成这种需求，优先队列。



优先队列按照其作用不同，可以分为以下两种：

- *最大优先队列：可以获取并删除队列中最大的值*
- *最小优先队列：可以获取并删除队列中最小的值*



## 1、最大优先队列

### 1、API设计

| 类名     | MaxPriorityQueue                                             |
| -------- | ------------------------------------------------------------ |
| 构造方法 | MaxPriorityQueue(int capacity)：创建容量为capacity的MaxPriorityQueue对象 |
| 成员方法 | private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br>private void each(int i,int j):交换堆中i索引和j索引处的值<br>public T delMax():删除队列中最大的元素,并返回这个最大元素<br>public void insert(T t)：往队列中插入一个元素<br>private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br>private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置<br>public int size():获取队列中元素的个数<br>public boolean isEmpty():判断队列是否为空 |
| 成员变量 | private T items：用来存储元素的数组<br>private int N：记录堆中元素的个数 |



### 2、代码实现

```java
public class MaxPriorityQueue<T extends Comparable<T>> {

    private T[] items;

    private int size;

    public MaxPriorityQueue(int capacity){
        items = (T[]) new Comparable[capacity + 1];
        size = 0;
    }

    /**
     * 判断堆中索引i处的元素是否小于索引j处的元素
     * @param i
     * @param j
     * @return true
     */
    private boolean less(int i,int j){
        return items[i].compareTo(items[j]) < 0;
    }

    /**
     * 交换堆中i索引和j索引处的值
     * @param i
     * @param j
     */
   private void each(int i,int j){
       T temp = items[i];
       items[i] = items[j];
       items[j] = temp;
   }

    /**
     * 删除队列中最大的元素,并返回这个最大元素
     * @return
     */
   public T delMax(){
       T max = items[1];
       each(1,size);
       items[size] = null;
       size--;
       sink(1);
       return max;
   }

    /**
     * 往队列中插入一个元素
     * @param t
     */
   public void insert(T t){
      items[++size] = t;
      swim(size);
   }

    /**
     * 使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置
     * @param k
     */
   private void swim(int k){
       while (1 < k){
           //比较k是否小于k/2，如果小于则交换元素
           if(less(k/2,k)){
               each(k/2,k);
           }
           k = k/2;
       }
   }

    /**
     * 使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置
     * @param k
     */
   private void sink(int k){
       while (2 * k <= size){
           int max = 2 * k;
           //如果存在右子结点
           if(2 * k + 1 <= size){
               if(less(2*k,2*k+1)){
                   max = 2 * k + 1;
               }
           }
           //比较当前结点和子结点中的较大者，如果当前结点不小，则结束循环
           if(!less(k,max)){
               break;
           }
           each(k,max);
           k = max;
       }
   }

    /**
     * 获取队列中元素的个数
     * @return
     */
   public int size(){
       return size;
   }


    /**
     * 判断队列是否为空
     * @return
     */
    public boolean isEmpty(){
        return size == 0;
    }
}
```

- 测试类

  ```java
  public class MaxPriorityQueueTest {
  
      public static void main(String[] args) {
          String[] arr = {"A", "B", "C", "D", "E", "F", "G"};
          MaxPriorityQueue<String> queue = new MaxPriorityQueue(10);
          for (String s : arr) {
              queue.insert(s);
          }
          System.out.println(queue.size());
          String max;
          while (!queue.isEmpty()){
              max = queue.delMax();
              System.out.print(max+ " ");
          }
      }
  }
  ```

  输出结果

  ```
  7
  G F E D C B A 
  ```

  

## 2、最小优先队列

> - 最小的元素放在数组的索引1处。
> - 每个结点的数据总是小于等于它的两个子结点的数据。



### 1、API设计

| 类名     | MinPriorityQueue                                             |
| -------- | ------------------------------------------------------------ |
| 构造方法 | MinPriorityQueue(int capacity)：创建容量为capacity的MinPriorityQueue对象 |
| 成员方法 | private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br/>private void exch(int i,int j):交换堆中i索引和j索引处的值<br/>public T delMin():删除队列中最小的元素,并返回这个最小元素<br/>public void insert(T t)：往队列中插入一个元素<br/>private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br/>private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置<br/>public int size():获取队列中元素的个数<br/>public boolean isEmpty():判断队列是否为空 |
| 成员变量 | private T[] imtes : 用来存储元素的数组<br/>private int N：记录堆中元素的个数 |

### 2、代码实现

```java
public class MinPriorityQueue<T extends Comparable<T>> {

    private T[] items;

    private int size;

    public MinPriorityQueue(int capacity){
        items = (T[]) new Comparable[capacity+1];
        size = 0;
    }

    /**
     * 判断堆中索引i处的元素是否小于索引j处的元素
     * @param i
     * @param j
     * @return
     */
    private boolean less(int i,int j){
        return items[i].compareTo(items[j]) < 0;
    }

    /**
     * 交换堆中i索引和j索引处的值
     * @param i
     * @param j
     */
    private void each(int i,int j){
        T temp = items[i];
        items[i] = items[j];
        items[j] = temp;
    }

    /**
     * 删除队列中最小的元素,并返回这个最小元素
     * @return
     */
    public T delMin(){
        T min = items[1];
        each(1,size);
        items[size] = null;
        size--;
        sink(1);
        return min;
    }

    /**
     * 往队列中插入一个元素<br/>
     * @param t
     */
    public void insert(T t){
        items[++size] = t;
        swim(size);
    }

    /**
     * :使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br/>
     * @param k
     */
    private void swim(int k){
        while (1 < k){
            if(less(k,k/2)){
                each(k,k/2);
            }
            k = k/2;
        }
    }

    /**
     * 使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置
     * @param k
     */
    private void sink(int k){
        while (2*k <= size){
            int min = 2*k;
            //如果存在右子结点
            if(2*k + 1 <= size){
                if(less(2*k + 1,2*k)){
                    min = 2*k + 1;
                }
            }
            if(less(k,min)){
                break;
            }
            each(min,k);
            k = min;
        }
    }

    /**
     * 获取队列中元素的个数
     * @return
     */
    public int size(){
        return size;
    }

    /**
     * 判断队列是否为空
     * @return
     */
    public boolean isEmpty(){
        return size == 0;
    }
}
```

- 测试类

  ```java
  public class MinPriorityQueueTest {
      public static void main(String[] args) {
          String[] arr = {"G", "F", "E", "D", "C", "B", "A"};
          MinPriorityQueue<String> queue = new MinPriorityQueue(10);
          for (String s : arr) {
              queue.insert(s);
          }
          System.out.println(queue.size());
          String del;
          while (!queue.isEmpty()){
              del = queue.delMin();
              System.out.print(del+" ");
          }
      }
  }
  ```

  输出结果

  ```
  7
  A B C D E F G 
  ```



## 3、索引优先队列

### 1、实现思路

1. 存储数据时，给每一个数据元素关联一个整数，例如insert(int k,T t),我们可以看做k是t关联的整数，那么我们的实现需要通过k这个值，快速获取到队列中t这个元素，此时有个k这个值需要具有唯一性。

   > 最直观的想法就是我们可以用一个T[] items数组来保存数据元素，在insert(int k,T t)完成插入时，可以把k看做是items数组的索引，把t元素放到items数组的索引k处，这样我们再根据k获取元素t时就很方便了，直接就可以拿到items[k]即可。

   

2. 第一步完成后的结果，虽然我们给每个元素关联了一个整数，并且可以使用这个整数快速的获取到该元素，但是，items数组中的元素顺序是随机的，并不是堆有序的，所以，为了完成这个需求，我们可以增加一个数组int[]pq,来保存每个元素在items数组中的索引，pq数组需要堆有序，也就是说，pq[1]对应的数据元素items[pq[1]]要小于等于pq[2]和pq[3]对应的数据元素items[pq[2]]和items[pq[3]]。

   

3. 通过第二步的分析，我们可以发现，其实我们通过上浮和下沉做堆调整的时候，其实调整的是pq数组。如果需要对items中的元素进行修改，比如让items[0]=“H”,那么很显然，我们需要对pq中的数据做堆调整，而且是调整pq[9]中元素的位置。但现在就会遇到一个问题，我们修改的是items数组中0索引处的值，如何才能快速的知道需要挑中pq[9]中元素的位置呢？

   > 最直观的想法就是遍历pq数组，拿出每一个元素和0做比较，如果当前元素是0，那么调整该索引处的元素即可，但是效率很低。
   > 我们可以另外增加一个数组，int[] qp,用来存储pq的逆序。例如：
   > 在pq数组中：pq[1]=6;
   > 那么在qp数组中，把6作为索引，1作为值，结果是：qp[6]=1;



当有了pq数组后，如果我们修改items[0]="H"，那么就可以先通过索引0，在qp数组中找到qp的索引：qp[0]=9,那么直接调整pq[9]即可。



### 2、API设计

| 类名     | IndexMinPriorityQueue                                        |
| -------- | ------------------------------------------------------------ |
| 构造方法 | IndexMinPriorityQueue(int capacity)：创建容量为capacity的IndexMinPriorityQueue对象 |
| 成员方法 | private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br/>private void exch(int i,int j):交换堆中i索引和j索引处的值<br/>public int delMin():删除队列中最小的元素,并返回该元素关联的索引<br/>public void insert(int i,T t)：往队列中插入一个元素,并关联索引i<br/>private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br/>private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置<br/>public int size():获取队列中元素的个数<br/>public boolean isEmpty():判断队列是否为空<br/>public boolean contains(int k):判断k对应的元素是否存在<br/>public void changeItem(int i, T t):把与索引i关联的元素修改为为t<br/>public int minIndex():最小元素关联的索引<br/>public void delete(int i):删除索引i关联的元素 |
| 成员变量 | private T[] imtes : 用来存储元素的数组<br/>private int[] pq:保存每个元素在items数组中的索引，pq数组需要堆有序<br/>private int [] qp:保存qp的逆序，pq的值作为索引，pq的索引作为值<br/>private int N：记录堆中元素的个数 |

### 3、代码实现

```java
public class IndexMinPriorityQueue<T extends Comparable<T>> {

    /**
     * 堆中元素
     */
    private T[] items;

    /**
     * 元素个数
     */
    private int size;
    /**
     * 保存每个元素在items数组中的索引，pq数组需要堆有序
     */
    private int[] pq;
    /**
     * 保存qp的逆序，pq的值作为索引，pq的索引作为值
     */
    private int[] qp;

    public IndexMinPriorityQueue(int capacity){
        items = (T[]) new Comparable[capacity+1];
        size = 0;
        qp = new int[capacity+1];
        pq = new int[capacity+1];
        Arrays.fill(qp, -1);
    }

    /**
     * 判断堆中索引i处的元素是否小于索引j处的元素
     * @param i
     * @param j
     * @return
     */
    private boolean less(int i,int j){
        return items[pq[i]].compareTo(items[pq[j]]) < 0;
    }

    /**
     * 换堆中i索引和j索引处的值
     * @param i
     * @param j
     */
    private void swap(int i,int j){
        //先交换pq数组中的值
        int temp = pq[i];
        pq[i] = pq[j];
        pq[j] = temp;

        //更新qp数组中的值
        qp[pq[i]] = i;
        qp[pq[j]] = j;
    }

    /**
     * 删除队列中最小的元素,并返回该元素关联的索引
     * @return
     */
    public int delMin(){
        //找到items中最小元素的索引
        int minIndex = pq[1];
        //交换pq中索引1处的值和N处的值
        swap(1, size);
        //删除qp中索引pq[N]处的值
        qp[pq[size]] = -1;
        //删除pq中索引N处的值
        pq[size] = -1;
        //删除items中的最小元素
        items[minIndex] = null;
        //元素数量-1
        size--;
        //对pq[1]做下沉，让堆有序
        sink(1);
        return minIndex;
    }

    /**
     * 往队列中插入一个元素,并关联索引i
     * @param i
     * @param t
     */
    public void insert(int i,T t){
        if(contains(i)){
            throw new RuntimeException("该索引已存在！");
        }
        size++;
        //把元素存放到items数组中
        items[i] = t;
        //使用pq存放i这个索引
        pq[size] = i;
        //在qp的i索引处存放N
        qp[i] = size;
        //上浮items[pq[N]],让pq堆有序
        swim(size);

    }

    /**
     * 使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置
     * @param k
     */
    private void swim(int k){
        while (1 < k){
            //比较当前结点和父结点，如果当前结点比父结点小，则交换位置
            if(less(k,k/2)){
                swap(k,k/2);
            }
            k = k/2;
        }
    }

    /**
     * :使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置
     * @param k
     */
    private void sink(int k){
        //如果当前结点已经没有子结点了，则结束下沉
        while (2*k <= size){
            int min = 2*k;
            if(2*k+1 <= size && less(2*k+1,2*k)){
                min = 2*k + 1;
            }
            if(less(k,min)){
                break;
            }
            swap(k,min);
            k = min;
        }
    }

    /**
     * :获取队列中元素的个数
     * @return
     */
    public int size(){
        return size;
    }

    /**
     * :判断队列是否为空
     * @return
     */
    public boolean isEmpty(){
        return size == 0;
    }

    /**
     * :判断k对应的元素是否存在
     * @param k
     * @return
     */
    public boolean contains(int k){
        //默认情况下，qp的所有元素都为-1，如果某个位置插入了数据，则不为-1
        return qp[k] != -1;
    }

    /**
     * :把与索引i关联的元素修改为为t
     * @param i
     * @param t
     */
    public void changeItem(int i, T t){
        //修改item数组中索引i的值为t
        items[i] = t;
        //找到i在pq中的位置
        int i1 = pq[i];
        //对pq[i1]做下沉，让堆有序
        sink(i1);
        //对pq[k]做上浮，让堆有序
        swim(i1);
    }

    /**
     * :最小元素关联的索引
     * @return
     */
    public int minIndex(){
        //pq的索引1处，存放的是最小元素在items中的索引
        return pq[1];
    }

    /**
     * :删除索引i关联的元素
     * @param i
     */
    public void delete(int i){
        //找出i在pq中的索引
        int k = pq[i];
        //把pq中索引k处的值和索引N处的值交换
        swap(k,size);
        //删除qp中索引pq[N]处的值
        qp[pq[size]] = -1;
        //删除pq中索引N处的值
        pq[size] = -1;
        //删除items中索引i处的值
        items[i] = null;
        //元素数量-1
        size--;
        //对pq[k]做下沉，让堆有序
        sink(k);
        //对pq[k]做上浮，让堆有序
        swim(k);
    }
}
```

- 测试类

  ```java
  public class IndexMinPriorityQueueTest {
  
      public static void main(String[] args) {
          String[] arr = {"S", "O", "R", "T", "E", "X", "A", "M", "P", "L", "E"};
          IndexMinPriorityQueue<String> indexMinPQ = new IndexMinPriorityQueue<>(20);
              //插入
          for (int i = 0; i < arr.length; i++) {
              indexMinPQ.insert(i,arr[i]);
          }
          System.out.println(indexMinPQ.size());
          //获取最小值的索引
          System.out.println(indexMinPQ.minIndex());
          //测试修改
          indexMinPQ.changeItem(0,"Z");
          int minIndex=-1;
          while(!indexMinPQ.isEmpty()){
              minIndex = indexMinPQ.delMin();
              System.out.print(minIndex+",");
          }
      }
  }
  ```

  输出

  ```
  11
  6
  10,4,9,7,1,8,2,3,5,0,0,
  ```



# 10、树的进阶

## 1、平衡树--查找树

### 1、查找树的定义

> 一棵2-3查找树要么为空，要么满足满足下面两个要求：
>
> - 2-结点
>
>   含有一个键(及其对应的值)和两条链，左链接指向2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。
>
> - 3-结点
>
>   含有两个键(及其对应的值)和三条链，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。



### 2、查找树的操作

#### 1、查找

> 将二叉查找树的查找算法一般化我们就能够直接得到2-3树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的连接，并在其指向的子树中递归地继续查找。如果这个是空链接，查找未命中。



#### 2、插入

##### 1、向2-结点中插入新键

> 往2-3树中插入元素和往二叉查找树中插入元素一样，首先要进行查找，然后将节点挂到未找到的节点上。2-3树之所以能够保证在最差的情况下的效率的原因在于其插入之后仍然能够保持平衡状态。如果查找后未找到的节点是一个2-结点，那么很容易，我们只需要将新的元素放到这个2-结点里面使其变成一个3-结点即可。但是如果查找的节点结束于一个3-结点，那么可能有点烦。



##### 2、向一棵只含有一个3-结点的树中插入新键

> 假设2-3树只包含一个3-结点，这个结点有两个键，没有空间来插入第三个键了，最自然的方式是我们假设这个结点能存放三个元素，暂时使其变成一个4-结点，同时他包含四条链接。然后，我们将这个4-结点的中间元素提升，左边的键作为其左子结点，右边的键作为其右子结点。插入完成，变为平衡2-3查找树，树的高度从0变为1。



##### 3、向一个父结点为2-结点的3-结点中插入新键

> 和上面的情况一样一样，我们也可以将新的元素插入到3-结点中，使其成为一个临时的4-结点，然后，将该结点中的中间元素提升到父结点即2-结点中，使其父结点成为一个3-结点，然后将左右结点分别挂在这个3-结点的恰当位置。



##### 4、向一个父结点为3-结点的3-结点中插入新键

> 当我们插入的结点是3-结点的时候，我们将该结点拆分，中间元素提升至父结点，但是此时父结点是一个3-结点，插入之后，父结点变成了4-结点，然后继续将中间元素提升至其父结点，直至遇到一个父结点是2-结点，然后将其变为3-结点，不需要继续进行拆分。



##### 5、分解根结点

> 当插入结点到根结点的路径上全部是3-结点的时候，最终我们的根结点会编程一个临时的4-结点，此时，就需要将根结点拆分为两个2-结点，树的高度加1。



### 3、树的性质

#### 1、2-3树的性质

通过对2-3树插入操作的分析，我们发现在插入的时候，2-3树需要做一些局部的变换来保持2-3树的平衡。

> 一棵完全平衡的2-3树具有以下性质：
>
> - 任意空链接到根结点的路径长度都是相等的。
>
> - 4-结点变换为3-结点时，树的高度不会发生变化，只有当根结点是临时的4-结点，分解根结点时，树高+1。
>
> - 2-3树与普通二叉查找树最大的区别在于，普通的二叉查找树是自顶向下生长，而2-3树是自底向上生长。

### 4、树的实现

#### 1、2-3的实现

> 直接实现2-3树比较复杂，因为：
>
> - 需要处理不同的结点类型，非常繁琐；
> - 需要多次比较操作来将结点下移；
> - 需要上移来拆分4-结点；
> - 拆分4-结点的情况有很多种；

2-3查找树实现起来比较复杂，在某些情况插入后的平衡操作可能会使得效率降低。但是2-3查找树作为一种比较重要的概念和思路对于我们后面要讲到的红黑树、B树和B+树非常重要。



## 2、平衡树--红黑树

我们前面介绍了2-3树，可以看到2-3树能保证在插入元素之后，树依然保持平衡状态，它的最坏情况下所有子结点都是2-结点，树的高度为lgN,相比于我们普通的二叉查找树，最坏情况下树的高度为N，确实保证了最坏情况下的时间复杂度，但是2-3树实现起来过于复杂，所以我们介绍一种2-3树思想的简单实现：红黑树。

> 红黑树主要是对2-3树进行编码，红黑树背后的基本思想是用标准的二叉查找树(完全由2-结点构成)和一些额外的信
> 息(替换3-结点)来表示2-3树。我们将树中的链接分为两种类型：
>
> - 红链接：将两个2-结点连接起来构成一个3-结点
> - 黑链接：2-3树中的普通链接
>
> 我们将3-结点表示为由由一条左斜的红色链接(两个2-结点其中之一是另一个的左子结点)相连的两个2-结点。这种表示法的一个优点是，我们无需修改就可以直接使用标准的二叉查找树的get方法。



### 1、红黑树的定义

> 红黑树是含有红黑链接并满足下列条件的二叉查找树：
>
> - 红链接均为左连接
> - 没有任何一个节点同时和两条红链接相连
> - 该树是完美黑色平衡的，即是任意空链接到根节点的路径上的黑链接数量相同

红黑树与2-3树的对应关系：





### 2、红黑树的API

> 因为每个结点都只会有一条指向自己的链接（从它的父结点指向它），我们可以在之前的Node结点中添加一个布尔类型的变量color来表示链接的颜色。如果指向它的链接是红色的，那么该变量的值为true，如果链接是黑色的，那么该变量的值为false。



API设计



| 类名     | Node<Key,Value>                                              |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Node(Key key, Value value, Node left, Node right，boolean color)：创建Node对象 |
| 成员变量 | public Node left:记录左子结点<br/>public Node right:记录右子结点<br/>public Key key:存储键<br/>public Value value:存储值<br/>public boolean color:由其父结点指向它的链接的颜色 |



### 3、平衡化

> 在对红黑树进行一些增删改查的操作后，很有可能会出现红色的右链接或者两条连续红色的链接，而这些都不满足红黑树的定义，所以我们需要对这些情况通过旋转进行修复，让红黑树保持平衡。

#### 1、左旋

> 当某个结点的左子结点为黑色，右子结点为红色，此时需要左旋。

*前提：当前结点为h，它的右子结点为x；*

*左旋过程：*

1. 让x的左子结点变为h的右子结点：

   ```java
   h.right=x.left;
   ```

2. 让h成为x的左子结点：

   ```java
   x.left=h;
   ```

3. 让h的color属性变为x的color属性值：

   ```java
   x.color=h.color;
   ```

4. 让h的color属性变为RED：

   ```java
   h.color=true;
   ```



#### 2、右旋

> 当某个结点的左子结点是红色，且左子结点的左子结点也是红色，需要右旋

*前提：当前结点为h，它的左子结点为x；*

*右旋过程：*

1. 让x的右子结点成为h的左子结点：

   ```java
   h.left = x.right;
   ```

2. 让h成为x的右子结点：

   ```java
   x.right=h;
   ```

3. 让x的color变为h的color属性值：

   ```java
   x.color = h.color;
   ```

4. 让h的color为RED；



### 4、操作

#### 1、向单个2-结点中插入新键

> 一棵只含有一个键的红黑树只含有一个2-结点。插入另一个键后，我们马上就需要将他们旋转。

- 如果新键小于当前结点的键，我们只需要新增一个红色结点即可，新的红黑树和单个3-结点完全等价。

  

- 如果新键大于当前结点的键，那么新增的红色结点将会产生一条红色的右链接，此时我们需要通过左旋，把红色右链接变成左链接，插入操作才算完成。形成的新的红黑树依然和3-结点等价，其中含有两个键，一条红色链接。

  

#### 2、向底部的2-结点插入新键

> 用和二叉查找树相同的方式向一棵红黑树中插入一个新键，会在树的底部新增一个结点（可以保证有序性），唯一区别的地方是我们会用红链接将新结点和它的父结点相连。如果它的父结点是一个2-结点，那么刚才讨论的两种方式仍然适用。



#### 3、颜色反转

> 当一个结点的左子结点和右子结点的color都为RED时，也就是出现了临时的4-结点，此时只需要把左子结点和右子结点的颜色变为BLACK，同时让当前结点的颜色变为RED即可。



#### 4、向一棵双键树(即一个3-结点)中插入新键

这种情况分为三种情况：

1. 新键大于原树中的两个键

   

2. 新键小于原树中的两个键

   

3. 新键介于原树中两个键之间

   



#### 5、根节点的颜色总是黑色

> 由于根结点不存在父结点，所以每次插入操作后，我们都需要把根结点的颜色设置为黑色。

#### 6、向树底部的3-结点插入新键

> 假设在树的底部的一个3-结点下加入一个新的结点。前面我们所讲的3种情况都会出现。指向新结点的链接可能是：
>
> - 3-结点的右链接（此时我们只需要转换颜色即可）
> - 或是左链接(此时我们需要进行右旋转然后再转换)
> - 或是中链接(此时需要先左旋转然后再右旋转，最后转换颜色)。
>
> 颜色转换会使中间结点的颜色变红，相当于将它送入了父结点。这意味着父结点中继续插入一个新键，我们只需要使用相同的方法解决即可，直到遇到一个2-结点或者根结点为止。





### 5、API的设计

| 类名     | RedBlackTree<Key,Value>                                      |
| -------- | ------------------------------------------------------------ |
| 构造方法 | RedBlackTree()：创建RedBlackTree对象                         |
| 成员方法 | 1.private boolean isRed(Node x)：判断当前结点的父指向链接是否为红色<br/>2.private Node rotateLeft(Node h):左旋调整<br/>3.private Node rotateRight(Node h):右旋调整<br/>4.private void flipColors(Node h)：颜色反转,相当于完成拆分4-结点<br/>5.public void put(Key key, Value val):在整个树上完成插入操作<br/>6.private Node put(Node h, Key key, Value val):在指定树中，完成插入操作,并返回添加元素后<br/>新的树<br/>7.public Value get(Key key):根据key，从树中找出对应的值<br/>8.private Value get(Node x, Key key):从指定的树x中，找出key对应的值<br/>9.public int size():获取树中元素的个数 |
| 成员变量 | 1.private Node root : 记录根结点<br/>2.private int N:记录树中元素的个数<br/>3.private static final boolean RED：红色链接标识<br/>4.private static final boolean BLACK:黑色链接标识 |

### 6、代码实现

```java
public class RedBlackTree<Key extends Comparable<Key>,Value> {

    /**
     * 根结点
     */
    private Node root;

    /**
     * 元素个数
     */
    private int size;

    /**
     * 红链接
     */
    private static final boolean RED = true;

    /**
     * 黑链接
     */
    private static final boolean BLACK = false;

    /**
     * 判断当前结点的父指向链接是否为红色
     * @param x
     * @return
     */
    private boolean isRed(Node x){
        if (x == null) {
            return false;
        }
        return x.color == RED;
    }

    /**
     * 左旋调整
     * @param h
     * @return
     */
    private Node rotateLeft(Node h){
        //找到当前节点的右子结点
        Node rightNode = h.right;
        //找到右子结点的左子结点
        Node left = rightNode.left;
        //让当前结点h的右子结点的左子结点成为当前结点的右子结点
        h.right = left;
        //让当前节点h变为rightNode的左子节点
        rightNode.left = h;
        //让当前结点h的color变成右子结点的color
        rightNode.color = h.color;
        //让当前结点的color变成RED
        h.color = RED;
        return rightNode;
    }

    /**
     * 右旋调整
     * @param h
     * @return
     */
    private Node rotateRight(Node h){
        //找到当前结点的左子结点
        Node leftNode = h.left;
        //找到leftNode的右子结点
        Node right = leftNode.right;
        //让right变成当前结点的左子结点
        h.left = right;
        //让当前节点变为leftNode的右子结点
        leftNode.right = h;
        //让当前结点h的color值变为左子结点的color值
        leftNode.color = h.color;
        //让当前结点的color变为RED
        h.color = RED;
        return leftNode;
    }

    /**
     * 颜色反转,相当于完成拆分4-结点
     * @param h
     */
    private void flipColors(Node h){
        //当前结点变为RED
        h.color = RED;
        //左右子结点的color变为BLACK
        h.left.color = BLACK;
        h.right.color = BLACK;
    }

    /**
     * 在整个树上完成插入操作
     * @param key
     * @param val
     */
    public void put(Key key, Value val){
        root = put(root,key,val);
        //让根节点颜色变为BLACK
        root.color = BLACK;
    }

    /**
     * 在指定树中，完成插入操作,并返回添加元素后新的树
     * @param h
     * @param key
     * @param val
     * @return
     */
    private Node put(Node h, Key key, Value val){
        //根结点
        if (h == null) {
            size++;
            return new Node(null,null,key,val,RED);
        }
        //比较当前节点的键与key
        int compare = key.compareTo(h.key);
        if(compare < 0){
            //往左子结点插入
            h.left = put(h.left,key,val);
        }else if(compare > 0){
            //往右子结点插入
            h.right = put(h.right,key,val);
        }else {
            //更新值
            h.value = val;
        }
        //如果当前结点的右链接是红色，左链接为黑色，需要左旋
        if(isRed(h.right) && !isRed(h.left)){
            h = rotateLeft(h);
        }
        //如果当前节点的左子结点以及左子结点的左子结点都是红链接，需要右旋
        if(isRed(h.right) && isRed(h.right.right)){
            h = rotateRight(h);
        }
        //颜色变换：当前节点的左右子结点都是红链接
        if(isRed(h.right) && isRed(h.left)){
            flipColors(h);
        }
        return h;
    }

    /**
     * 根据key，从树中找出对应的值
     * @param key
     * @return
     */
    public Value get(Key key){
        return get(root,key);
    }

    /**
     * 从指定的树x中，找出key对应的值
     * @param x
     * @param key
     * @return
     */
    private Value get(Node x, Key key){
        if (x == null) {
            return null;
        }
        int compare = key.compareTo(x.key);
        if(0 > compare){
            return get(x.left,key);
        }else if(0 < compare){
            return get(x.right,key);
        }else {
            return x.value;
        }
    }

    /**
     * 获取树中元素的个数
     * @return
     */
    public int size(){
        return size;
    }


    /**
     * 结点类
     */
    private class Node{
        public Node left;
        public Node right;
        public Key key;
        public Value value;
        public boolean color;

        public Node(Node left, Node right, Key key, Value value, boolean color) {
            this.left = left;
            this.right = right;
            this.key = key;
            this.value = value;
            this.color = color;
        }
    }
}
```

- 测试类

  ```java
  public class RedBlackTreeTest {
  
      public static void main(String[] args) {
          RedBlackTree<Integer, String> tree = new RedBlackTree<>();
          tree.put(1,"1111");
          tree.put(2,"2222");
          tree.put(3,"3333");
          tree.put(4,"4444");
          System.out.println(tree.size());
          tree.put(2,"666666");
          System.out.println(tree.get(2));
      }
  }
  ```

  

## 3、B-树

> 前面我们已经学习了二叉查找树、2-3树以及它的实现红黑树。2-3树中，一个结点做多能有两个key，它的实现红黑树中使用对链接染色的方式去表达这两个key。接下来我们学习另外一种树型结构B树，这种数据结构中，一个结点允许多于两个key的存在。
>
> B树是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(logn)的时间复杂度进行查找、顺序读取、插入和删除等操作。

### 1、B-树的特性

> B树中允许一个结点中包含多个key，可以是3个、4个、5个甚至更多，并不确定，需要看具体的实现。现在我们选择一个参数M，来构造一个B树，我们可以把它称作是M阶的B树，那么该树会具有如下特点：
>
> - 每个结点最多有M-1个Key，并且升序排列
> - 每个结点最多有M个子结点
> - 根节点至少有两个子结点



在实际应用中B树的阶数一般都比较大（通常大于100），所以，即使存储大量的数据，B树的高度仍然比较小，这样在某些应用场景下，就可以体现出它的优势。

### 2、B-树存储数据

若参数M选择为5，那么每个结点最多包含4个键值对，我们以5阶B树为例，看看B树的数据存储。



### 3、B树在磁盘文件中的应用

> 在我们的程序中，不可避免的需要通过IO操作文件，而我们的文件是存储在磁盘上的。计算机操作磁盘上的文件是通过文件系统进行操作的，在文件系统中就使用到了B树这种数据结构。

#### 1、磁盘

> 磁盘能够保存大量的数据，从GB一直到TB级，但是 他的读取速度比较慢，因为涉及到机器操作，读取速度为毫秒级 。



磁盘由盘片构成,每个盘片有两面，又称为盘面 。盘片中央有一个可以旋转的主轴，他使得盘片以固定的旋转速率旋转，通常是5400rpm或者是7200rpm,一个磁盘中包含了多个这样的盘片并封装在一个密封的容器内 。盘片的每个表面是由一组称为磁道同心圆组成的 ，每个磁道被划分为了一组扇区 ，每个扇区包含相等数量的数据位，通常是512个子节，扇区之间由一些间隙隔开,这些间隙中不存储数据 。

#### 2、磁盘IO



> 磁盘用磁头来读写存储在盘片表面的位，而磁头连接到一个移动臂上，移动臂沿着盘片半径前后移动，可以将磁头定位到任何磁道上，这称之为寻道操作。一旦定位到磁道后，盘片转动，磁道上的每个位经过磁头时，读写磁头就可以感知到该位的值，也可以修改值。对磁盘的访问时间分为 寻道时间，旋转时间，以及传送时间。

由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，因此为了提高效率，要尽量减少磁盘I/O，减少读写操作。 为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此预读可以提高I/O效率。

> 页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（1024个字节或其整数倍），预读的长度一般为页的整倍数。主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。

> 文件系统的设计者利用了磁盘预读原理，将一个结点的大小设为等于一个页（1024个字节或其整数倍），这样每个结点只需要一次I/O就可以完全载入。那么3层的B树可以容纳102410241024差不多10亿个数据，如果换成二叉查找树，则需要30层！假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在10亿个数据中查找目标值，只需要小于3次硬盘读取就可以找到目标值，但红黑树需要小于30次，因此B树大大提高了IO的操作效率。



## 4、B+树

> B+树是对B树的一种变形树，它与B树的差异在于：
> 1. 非叶结点仅具有索引作用，也就是说，非叶子结点只存储key，不存储value；
> 2. 树的所有叶结点构成一个有序链表，可以按照key排序的次序遍历全部数据。

### 1、B+树存储数据

> 若参数M选择为5，那么每个结点最多包含4个键值对，我们以5阶B+树为例，看看B+树的数据存储。





### 2、B+树和B树的对比

B+ 树的优点

> 由于B+树在非叶子结点上不包含真正的数据，只当做索引使用，因此在内存相同的情况下，能够存放更多的key。 2.B+树的叶子结点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。

B树的优点

> 由于B树的每一个节点都包含key和value，因此我们根据key查找value时，只需要找到key所在的位置，就能找到value，但B+树只有叶子结点存储数据，索引每一次查找，都必须一次一次，一直找到树的最大深度处，也就是叶子结点的深度，才能找到value。



### 3、B+树在数据库中的应用

> 在数据库的操作中，查询操作可以说是最频繁的一种操作，因此在设计数据库时，必须要考虑到查询的效率问题，在很多数据库中，都是用到了B+树来提高查询的效率；
> 在操作数据库时，我们为了提高查询效率，可以基于某张表的某个字段建立索引，就可以提高查询效率，那其实这个索引就是B+树这种数据结构实现的。

#### 1、未建立主键索引查询



执行

```sql
select * from user where id=18
```

 需要从第一条数据开始，一直查询到第6条，发现id=18，此时才能查询出目标结果，共需要比较6次；

#### 2、建立主键索引查询



#### 3、区间查询

```sql
select * from user where id>=12 and id<=18
```

 如果有了索引，由于B+树的叶子结点形成了一个有序链表，所以我们只需要找到id为12的叶子结点，按照遍历链表的方式顺序往后查即可，效率非常高。



# 11、并查集

> 并查集是一种树型的数据结构 ，并查集可以高效地进行如下操作：
>
> - 查询元素p和元素q是否属于同一组
> - 合并元素p和元素q所在的组



## 1、并查集的结构

> 并查集也是一种树型结构，但这棵树跟我们之前讲的二叉树、红黑树、B树等都不一样，这种树的要求比较简单：
>
> 1. 每个元素都唯一的对应一个结点；
> 2. 每一组数据中的多个元素都在同一颗树中；
> 3. 一个组中的数据对应的树和另外一个组中的数据对应的树之间没有任何联系；
> 4. 元素在树中并没有子父级关系的硬性要求；



## 2、并查集的API设计与实现

### 1、API设计

| 类名     | UnionFind                                                    |
| -------- | ------------------------------------------------------------ |
| 构造方法 | UF(int N)：初始化并查集，以整数标识(0,N-1)个结点             |
| 成员方法 | public int count()：获取当前并查集中的数据有多少个分组<br/>public boolean connected(int p,int q):判断并查集中元素p和元素q是否在同一分组中<br/>public int find(int p):元素p所在分组的标识符<br/>public void union(int p,int q)：把p元素所在分组和q元素所在分组合并 |
| 成员变量 | private int[] eleAndGroup: 记录结点元素和该元素所在分组的标识<br/>private int count：记录并查集中数据的分组个数 |

### 2、实现

#### 1、UF(int N)构造方法实现

1. 初始情况下，每个元素都在一个独立的分组中，所以，初始情况下，并查集中的数据默认分为N个组；
2. 初始化数组eleAndGroup；
3. 把eleAndGroup数组的索引看做是每个结点存储的元素，把eleAndGroup数组每个索引处的值看做是该结点所在的分组，那么初始化情况下，i索引处存储的值就是i



#### 2、union(int p,int q)合并方法实现

1. 如果p和q已经在同一个分组中，则无需合并
2. 如果p和q不在同一个分组，则只需要将p元素所在组的所有的元素的组标识符修改为q元素所在组的标识符即可
3. 分组数量-1



#### 3、代码实现

```java
public class UnionFind {

    /**
     * 记录结点元素和该元素所在分组的标识
     */
    private int[] eleAndGroup;

    /**
     * 记录并查集中数据的分组个数
     */
    private int count;

    public UnionFind(int n) {
        //初始情况下，每个元素都在一个独立的分组中，所以，初始情况下，并查集中的数据默认分为N个组
        this.count = n;
        //初始化数组
        eleAndGroup = new int[n];
        //把eleAndGroup数组的索引看做是每个结点存储的元素，
        // 把eleAndGroup数组每个索引处的值看做是该结点所在的分组，
        // 那么初始化情况下，i索引处存储的值就是i
        for (int i = 0; i < n; i++) {
            eleAndGroup[i] = i;
        }
    }

    /**
     * 获取当前并查集中的数据有多少个分组
     * @return
     */
    public int count(){
        return count;
    }

    /**
     * 判断并查集中元素p和元素q是否在同一分组中
     * @param p
     * @param q
     * @return
     */
    public boolean connected(int p,int q){
        return eleAndGroup[p] == eleAndGroup[q];
    }

    /**
     * 元素p所在分组的标识符
     * @param p
     * @return
     */
    public int find(int p){
        return eleAndGroup[p];
    }

    /**
     * 把p元素所在分组和q元素所在分组合并
     * @param p
     * @param q
     */
    public void union(int p,int q){
        //如果q和p已经在同一个分组中，不需要合并
        if(connected(p, q)){
            return;
        }
        //不在一个分组中
        int pFind = find(p);
        int qFind = find(q);
        for (int i = 0; i < eleAndGroup.length; i++) {
            if (eleAndGroup[i] == pFind){
                eleAndGroup[i] = qFind;
            }
        }
        //数量减1
        count--;
    }
}
```

- 测试类

  ```java
  public class UnionFindTest {
  
      public static void main(String[] args) {
          UnionFind uf = new UnionFind(5);
          int count = uf.count();
          System.out.println("总共有"+count+"个分组");
          Scanner scanner = new Scanner(System.in);
          while (true){
              System.out.println("请输入你要合并的第一个点");
              int i = scanner.nextInt();
              System.out.println("请输入你要合并的第二个点");
              int j = scanner.nextInt();
              if(uf.connected(i,j)){
                  System.out.println("结点"+ i +"和结点"+ j +"已经在同一个组");
                  continue;
              }
              uf.union(i,j);
              System.out.println("总共还有"+uf.count()+"个分组");
          }
      }
  }
  ```



## 3、并查集应用举例

> 如果我们并查集存储的每一个整数表示的是一个大型计算机网络中的计算机，则我们就可以通过connected(intp,int q)来检测，该网络中的某两台计算机之间是否连通？如果连通，则他们之间可以通信，如果不连通，则不能通信，此时我们又可以调用union(int p,int q)使得p和q之间连通，这样两台计算机之间就可以通信了。
>
> 一般像计算机这样网络型的数据，我们要求网络中的每两个数据之间都是相连通的，也就是说，我们需要调用很多次union方法，使得网络中所有数据相连，其实我们很容易可以得出，如果要让网络中的数据都相连，则我们至少要调用N-1次union方法才可以，但由于我们的union方法中使用for循环遍历了所有的元素，所以很明显，我们之前实现的合并算法的时间复杂度是O(N^2)，如果要解决大规模问题，它是不合适的，所以我们需要对算法进行优化。



## 4、算法优化

> 为了提升union算法的性能，我们需要重新设计find方法和union方法的实现，此时我们先需要对我们的之前数据结构中的eleAndGourp数组的含义进行重新设定：
>
> - 我们仍然让eleAndGroup数组的索引作为某个结点的元素；
> - eleAndGroup[i]的值不再是当前结点所在的分组标识，而是该结点的父结点；



### 1、API设计

| 类名     | UF_Tree                                                      |
| -------- | ------------------------------------------------------------ |
| 构造方法 | UF_Tree(int N)：初始化并查集，以整数标识(0,N-1)个结点        |
| 成员方法 | public int count()：获取当前并查集中的数据有多少个分组<br/>public boolean connected(int p,int q):判断并查集中元素p和元素q是否在同一分组中<br/>public int find(int p):元素p所在分组的标识符<br/>public void union(int p,int q)：把p元素所在分组和q元素所在分组合并 |
| 成员变量 | private int[] eleAndGroup: 记录结点元素和该元素的父结点<br/>private int count：记录并查集中数据的分组个数 |

### 2、实现

#### 1、find(int p)查询方法实现

> 1. 判断当前元素p的父结点eleAndGroup[p]是不是自己，如果是自己则证明已经是根结点了；
> 2. 如果当前元素p的父结点不是自己，则让p=eleAndGroup[p]，继续找父结点的父结点,直到找到根结点为止；



#### 2、union(int p,int q)合并方法实现

> 1. 找到p元素所在树的根结点
> 2. 找到q元素所在树的根结点
> 3. 如果p和q已经在同一个树中，则无需合并；
> 4. 如果p和q不在同一个分组，则只需要将p元素所在树根结点的父结点设置为q元素的根结点即可；
> 5. 分组数量-1





### 3、完成代码

```java
public class UF_Tree {

    /**
     * 记录结点元素和该元素所在分组的标识
     */
    private int[] eleAndGroup;

    /**
     * 记录并查集中数据的分组个数
     */
    private int count;

    public UF_Tree(int n) {
        //初始情况下，每个元素都在一个独立的分组中，所以，初始情况下，并查集中的数据默认分为N个组
        this.count = n;
        //初始化数组
        eleAndGroup = new int[n];
        //把eleAndGroup数组的索引看做是每个结点存储的元素，
        // 把eleAndGroup数组每个索引处的值看做是该结点所在的分组，
        // 那么初始化情况下，i索引处存储的值就是i
        for (int i = 0; i < n; i++) {
            eleAndGroup[i] = i;
        }
    }

    /**
     * 获取当前并查集中的数据有多少个分组
     * @return
     */
    public int count(){
        return count;
    }

    /**
     * 判断并查集中元素p和元素q是否在同一分组中
     * @param p
     * @param q
     * @return
     */
    public boolean connected(int p,int q){
        return eleAndGroup[p] == eleAndGroup[q];
    }

    /**
     * 元素p所在分组的标识符
     * @param p
     * @return
     */
    public int find(int p){
        while (true){
            //判断当前元素p的父结点eleAndGroup[p]是不是自己，如果是自己则证明已经是根结点了；
            if(p == eleAndGroup[p]){
                return p;
            }
            //如果当前元素p的父结点不是自己，则让p=eleAndGroup[p]，继续找父结点的父结点,直到找到根结点为止；
            p = eleAndGroup[p];
        }
    }

    /**
     * 把p元素所在分组和q元素所在分组合并
     * @param p
     * @param q
     */
    public void union(int p,int q){
        //不在一个分组中
        int pFind = find(p);
        int qFind = find(q);
        if (qFind == pFind){
            return;
        }
        //如果p和q不在同一个分组，则只需要将p元素所在树根结点的父结点设置为q元素的根结点即可；
        eleAndGroup[pFind] = qFind;
        //数量减1
        count--;
    }
}
```



- 测试类

  ```java
  public class UnionFindTreeTest {
  
      public static void main(String[] args) {
          UF_Tree uf = new UF_Tree(5);
          int count = uf.count();
          System.out.println("总共有"+count+"个分组");
          Scanner scanner = new Scanner(System.in);
          while (true){
              System.out.println("请输入你要合并的第一个点");
              int i = scanner.nextInt();
              System.out.println("请输入你要合并的第二个点");
              int j = scanner.nextInt();
              if(uf.connected(i,j)){
                  System.out.println("结点"+ i +"和结点"+ j +"已经在同一个组");
                  continue;
              }
              uf.union(i,j);
              System.out.println("总共还有"+uf.count()+"个分组");
          }
      }
  }
  ```

  



## 5、路径压缩

> UF_Tree中最坏情况下union算法的时间复杂度为O(N^2)，其最主要的问题在于最坏情况下，树的深度和数组的大小一样，如果我们能够通过一些算法让合并时，生成的树的深度尽可能的小，就可以优化find方法。
>
> 之前我们在union算法中，合并树的时候将任意的一棵树连接到了另外一棵树，这种合并方法是比较暴力的，如果我们把并查集中每一棵树的大小记录下来，然后在每次合并树的时候，把较小的树连接到较大的树上，就可以减小树的深度。



只要我们保证每次合并，都能把小树合并到大树上，就能够压缩合并后新树的路径，这样就能提高find方法的效率。为了完成这个需求，我们需要另外一个数组来记录存储每个根结点对应的树中元素的个数，并且需要一些代码调整数组中的值。

### 1、API设计

| 类名     | UF_Tree_Weighted                                             |
| -------- | ------------------------------------------------------------ |
| 构造方法 | UF_Tree_Weighted(int N)：初始化并查集，以整数标识(0,N-1)个结点 |
| 成员方法 | public int count()：获取当前并查集中的数据有多少个分组<br>public boolean connected(int p,int q):判断并查集中元素p和元素q是否在同一分组中<br/>public int find(int p):元素p所在分组的标识符<br/>public void union(int p,int q)：把p元素所在分组和q元素所在分组合并 |
| 成员变量 | private int[] eleAndGroup: 记录结点元素和该元素的父结点<br/>private int[] sz: 存储每个根结点对应的树中元素的个数<br/>private int count：记录并查集中数据的分组个数 |



### 2、实现

```java
public class UFTreeWeighted {

    private int[] eleAndGroup;

    private int[] rootSize;

    private int count;

    public UFTreeWeighted(int count) {
        this.count = count;
        //初始化数组
        eleAndGroup = new int[count];
        rootSize = new int[count];
        /**
         * 把eleAndGroup数组的索引看做是每个结点存储的元素，
         * 把eleAndGroup数组每个索引处的值看做是该结点所在的分组，
         * 那么初始化情况下，i索引处存储的值就是i
         */
        for (int i = 0; i < count; i++) {
            eleAndGroup[i] = i;
        }
        //把sz数组中所有的元素初始化为1，默认情况下，每个结点都是一个独立的树，每个树中只有一个元素
        for (int i = 0; i < count; i++) {
            rootSize[i] = 1;
        }
    }

    /**
     * 获取当前并查集中的数据有多少个分组
     * @return count
     */
    public int count(){
        return count;
    }

    /**
     * 判断并查集中元素p和元素q是否在同一分组中
     * @param p
     * @param q
     * @return
     */
    public boolean connected(int p,int q){
        return find(p) == find(q);
    }

    /**
     * 元素p所在分组的标识符
     * @param p
     * @return
     */
    public int find(int p){
        while (true){
            if(p == eleAndGroup[p]){
                return p;
            }
            p = eleAndGroup[p];
        }
    }

    /**
     * ：把p元素所在分组和q元素所在分组合并
     * @param p
     * @param q
     */
    public void union(int p,int q){
        //找到p元素的根结点
        int pRoot = find(p);
        //找到q元素的根结点
        int qRoot = find(q);
        //如果已经在一个组中，无需合并
        if(pRoot == qRoot){
            return;
        }
        //不在一个组中，比较q所在树中的元素个数和p所在树中的元素个数，小树向大树合并
        if(rootSize[pRoot] < rootSize[qRoot]){
            eleAndGroup[pRoot] = qRoot;
            rootSize[qRoot] += rootSize[pRoot];
        }else {
            eleAndGroup[qRoot] = pRoot;
            rootSize[pRoot] += rootSize[qRoot];
        }
        //分组数组-1
        count--;
    }
}
```



# 12、图

## 1、图的定义及分类

> 图是由一组顶点和一组能够将两个顶点相连的边组成的



特殊的图：

> 1. 自环：即一条连接一个顶点和其自身的边；
> 2. 平行边：连接同一对顶点的两条边；

 

 图的分类

> 按照连接两个顶点的边的不同，可以把图分为以下两种：
>
> - 无向图：边仅仅连接两个顶点，没有其他含义；
> - 有向图：边不仅连接两个顶点，并且具有方向；

## 2、图的相关术语

### 1、相邻顶点

> 当两个顶点通过一条边相连时，我们称这两个顶点是相邻的，并且称这条边依附于这两个顶点。

### 2、度

> 某个顶点的度就是依附于该顶点的边的个数

### 3、子图

> 是一幅图的所有边的子集(包含这些边依附的顶点)组成的图；

### 4、路径

> 是由边顺序连接的一系列的顶点组成

### 5、环

> 是一条至少含有一条边且终点和起点相同的路径



### 6、连通图

> 如果图中任意一个顶点都存在一条路径到达另外一个顶点，那么这幅图就称之为连通图

### 7、连通子图

> 一个非连通图由若干连通的部分组成，每一个连通的部分都可以称为该图的连通子图





## 3、图的存储结构

> 要表示一幅图，只需要表示清楚以下两部分内容即可：
>
> 1. 图中所有的顶点；
> 2. 所有连接顶点的边；

### 1、邻接矩阵

> 1. 使用一个VV的二维数组intV adj,把索引的值看做是顶点；*
> 2. 如果顶点v和顶点w相连，我们只需要将adjv和adjw的值设置为1,否则设置为0即可。



很明显，邻接矩阵这种存储方式的空间复杂度是V^2的，如果我们处理的问题规模比较大的话，内存空间极有可能不够用。

### 2、邻接表

> 1.使用一个大小为V的数组 Queue[V] adj，把索引看做是顶点；
> 2.每个索引处adj[v]存储了一个队列，该队列中存储的是所有与该顶点相邻的其他顶点



很明显，邻接表的空间并不是是线性级别的，所以后面我们一直采用邻接表这种存储形式来表示图。



## 4、图的实现

### 1、图的API设计

| 类名     | Graph                                                        |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Graph(int V)：创建一个包含V个顶点但不包含边的图              |
| 成员方法 | public int V():获取图中顶点的数量<br/>public int E():获取图中边的数量<br/>public void addEdge(int v,int w):向图中添加一条边 v-w<br/>public Queue adj(int v)：获取和顶点v相邻的所有顶点 |
| 成员变量 | private final int V: 记录顶点数量<br/>private int E: 记录边数量<br/>private Queue[] adj: 邻接表 |

### 2、实现

```java
public class Graph {

    /**
     * :记录顶点数量
     */
    private final int V;
    /**
     * :记录边数量
     */
    private int E;
    /**
     * : 邻接表
     */
    private Queue[] adj;

    public Graph(int v){
        //初始化顶点数量
        this.V = v;
        //初始化边数量
        this.E = 0;
        //初始化邻接表
        this.adj = new Queue[v];
        for (int i = 0; i < adj.length; i++) {
            adj[i] = new Queue<Integer>();
        }
    }

    /**
     * 获取图中顶点的数量
     * @return
     */
    public int V(){
        return V;
    }

    /**
     * 获取图中边的数量
     * @return
     */
    public int E(){
        return E;
    }

    /**
     * 向图中添加一条边 v-w
     * @param v
     * @param w
     */
    public void addEdge(int v,int w){
        //把w增加到v的链表上，顶点v多了一个相邻点
        adj(v).enqueue(w);
        adj(w).enqueue(v);
        E++;
    }

    /**
     * 获取和顶点v相邻的所有顶点
     * @param v
     * @return
     */
    public Queue<Integer> adj(int v){
        return adj[v];
    }
}
```

- 测试类

  ```java
  public class GraphTest {
      public static void main(String[] args) {
  
          Graph graph = new Graph(20);
          graph.addEdge(0,5);
          graph.addEdge(0,1);
          graph.addEdge(0,2);
          graph.addEdge(0,6);
          graph.addEdge(6,4);
          graph.addEdge(4,3);
          graph.addEdge(4,5);
          graph.addEdge(5,3);
  
          graph.addEdge(7,8);
  
          graph.addEdge(9,10);
          graph.addEdge(9,11);
          graph.addEdge(11,12);
  
          System.out.println("图中边的数量为：" + graph.E());
  
          System.out.println("图中顶点的数量为：" + graph.V());
  
          graph.addEdge(5,7);
  
      }
  }
  ```



## 5、图的搜索

最经典的算法有：

- 深度优先搜索
- 广度优先搜索

### 1、深度优先搜索

> 所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找子结点，然后找兄弟结点。



> 很明显，在由于边是没有方向的，所以，如果4和5顶点相连，那么4会出现在5的相邻链表中，5也会出现在4的相邻链表中，那么为了不对顶点进行重复搜索，应该要有相应的标记来表示当前顶点有没有搜索过，可以使用一个布尔类型的数组 boolean[V] marked,索引代表顶点，值代表当前顶点是否已经搜索，如果已经搜索，标记为true，如果没有搜索，标记为false；



#### 1、API设计

| 类名     | DepthFirstSearch                                             |
| -------- | ------------------------------------------------------------ |
| 构造方法 | DepthFirstSearch(Graph G,int s)：构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相通顶点 |
| 成员方法 | private void dfs(Graph G, int v)：使用深度优先搜索找出G图中v顶点的所有相通顶点<br/>public boolean marked(int w):判断w顶点与s顶点是否相通<br/>public int count():获取与顶点s相通的所有顶点的总数 |
| 成员变量 | private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索<br/>private int count：记录有多少个顶点与s顶点相通 |

#### 2、代码实现

```java
public class DepthFirstSearch {

    /**
     * 索引代表顶点，值表示当前顶点是否已经被搜索
     */
    private boolean[] marked;

    /**
     * 记录有多少个顶点与s顶点相通
     */
    private int count;

    /**
     * 构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相通顶点
     * @param G
     * @param s
     */
    public DepthFirstSearch(Graph G,int s){
        //创建一个和图的顶点数一样大小的布尔数组
        marked = new boolean[G.V()];
        //搜索G图中与顶点s相同的所有顶点
        dfs(G, s);
    }

    /**
     * 使用深度优先搜索找出G图中v顶点的所有相通顶点
     * @param G
     * @param v
     */
    private void dfs(Graph G, int v){
        //把当前顶点标记为已搜索
        marked[v] = true;
        //遍历v顶点的邻接表，得到每一个顶点i
        for (Integer i : G.adj(v)) {
            //如果当前顶点i没有被搜索过，则递归搜索与w顶点相通的其他顶点
            if(!marked[i]){
                dfs(G,i);
            }
        }
        //相通的顶点数量+1
        count++;
    }

    /**
     * 判断w顶点与s顶点是否相通
     * @param w
     * @return
     */
    public boolean marked(int w){
        return marked[w];
    }

    /**
     * 获取与顶点s相通的所有顶点的总数
     * @return
     */
    public int count(){
        return count;
    }
}
```

- 测试类

  ```java
  public class DepthFirstSearchTest {
      public static void main(String[] args) {
  
          Graph graph = new Graph(20);
          graph.addEdge(0,5);
          graph.addEdge(0,1);
          graph.addEdge(0,2);
          graph.addEdge(0,6);
          graph.addEdge(6,4);
          graph.addEdge(4,3);
          graph.addEdge(4,5);
          graph.addEdge(5,3);
  
          graph.addEdge(7,8);
  
          graph.addEdge(9,10);
          graph.addEdge(9,11);
          graph.addEdge(11,12);
  
          DepthFirstSearch search = new DepthFirstSearch(graph, 0);
  
          System.out.println("与0相邻的顶点个数：" + search.count());
  
          System.out.println("0和5是否相邻：" + search.marked(5));
  
          System.out.println("0和7是否相邻：" + search.marked(7));
      }
  }
  ```

  

### 2、广度优先搜索

> 从根结点开始，沿着树的宽度遍历树的结点，如果所有结点被访问，则终止



#### 1、API设计

| 类名     | BreadthFirstSearch                                           |
| -------- | ------------------------------------------------------------ |
| 构造方法 | public BreadthFirstSearch(Graph G,int s)：构造广度优先搜索对象，使用广度优先搜索找到G图中s顶点的所有相邻顶点 |
| 成员方法 | private void bfs(Graph G, int v)：使用广度优先搜索找出G图中v顶点的所有相邻顶点<br/>public boolean marked(int w):判断w顶点与s顶点是否相通<br/>public int count():获取与顶点s相通的所有顶点的总数 |
| 成员变量 | private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索<br/>private int count：记录有多少个顶点与s顶点相通<br/>private Queue waitSearch: 用来存储待搜索邻接表的点 |

#### 2、代码实现

```java
public class BreadthFirstSearch {

    /**
     * :索引代表顶点，值表示当前顶点是否已经被搜索
     */
    private boolean[] marked;

    /**
     * 记录有多少个顶点与s顶点相通
     */
    private int count;

    /**
     * 用来存储待搜索邻接表的点
     */
    private Queue<Integer> waitSearch;

    /**
     * 使用广度优先搜索，找到g图中s顶点的所有相邻顶点
     * @param g
     * @param s
     */
    public BreadthFirstSearch(Graph g, int s){
        //创建一个和图一样的boolean数组
        marked = new boolean[g.V()];
        //初始化待搜索的索引
        waitSearch = new Queue<Integer>();
        bfs(g, s);
    }

    /**
     * 使用广度优先搜索找出G图中v顶点的所有相邻顶点
     * @param G
     * @param v
     */
    private void bfs(Graph G, int v){
        //标记当前v的搜索状态为true
        marked[v] = true;
        //将当前顶点放入队列中，等待搜索他的邻接表
        waitSearch.enqueue(v);
        //待搜索的队列不为空
        while (!waitSearch.isEmpty()){
            Integer dequeue = waitSearch.dequeue();
            //遍历wait顶点的邻接表，得到每一个顶点
            for (Integer w : G.adj(dequeue)) {
                if(!marked(w)){
                    bfs(G,w);
                }
            }
        }
        count++;
    }

    /**
     * 判断w顶点与s顶点是否相通
     * @param w
     * @return
     */
    public boolean marked(int w){
        return marked(w);
    }

    /**
     * 获取与顶点s相通的所有顶点的总数
     * @return
     */
    public int count(){
        return count;
    }
}
```

- 测试类

  ```java
  public class BreadthFirstSearchTest {
      public static void main(String[] args) {
  
          Graph graph = new Graph(20);
          graph.addEdge(0,5);
          graph.addEdge(0,1);
          graph.addEdge(0,2);
          graph.addEdge(0,6);
          graph.addEdge(6,4);
          graph.addEdge(4,3);
          graph.addEdge(4,5);
          graph.addEdge(5,3);
  
          graph.addEdge(7,8);
  
          graph.addEdge(9,10);
          graph.addEdge(9,11);
          graph.addEdge(11,12);
  
          BreadthFirstSearch search = new BreadthFirstSearch(graph, 0);
  
          System.out.println("与0相邻的顶点个数：" + search.count());
  
          System.out.println("0和5是否相邻：" + search.marked(5));
  
          System.out.println("0和7是否相邻：" + search.marked(7));
      }
  }
  ```

  

### 3、路径查找



例如在上图上查找顶点0到顶点4的路径用红色标识出来,那么我们可以把该路径表示为 0-2-3-4。

#### 1、API设计

| 类名     | DepthFirstPaths                                              |
| -------- | ------------------------------------------------------------ |
| 构造方法 | DepthFirstPaths(Graph G,int s)：构造深度优先搜索对象，使用深度优先搜索找出G图中起点为s的所有路径 |
| 成员方法 | private void dfs(Graph G, int v)：使用深度优先搜索找出G图中v顶点的所有相邻顶点<br/>public boolean hasPathTo(int v):判断v顶点与s顶点是否存在路径<br/>public Stack pathTo(int v):找出从起点s到顶点v的路径(就是该路径经过的顶点) |
| 成员变量 | private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索<br/>private int s:起点<br/>private int[] edgeTo:索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点 |



#### 2、代码实现

```java
public class DepthFirstPaths {

    /**
     * 索引代表顶点，值表示当前顶点是否已经被搜索
     */
    private boolean[] marked;
    /**
     * 起点
     */
    private int s;
    /**
     * 索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点
     */
    private int[] edgeTo;

    /**
     * 深度优先搜索
     * @param graph 图
     * @param s 起点
     */
    public DepthFirstPaths(Graph graph, int s){
        //初始化数组
        marked = new boolean[graph.V()];
        edgeTo = new int[graph.V()];

        this.s = s;
        dfs(graph, s);
    }

    /**
     * 使用深度优先搜索找出G图中v顶点的所有相邻顶点
     * @param G
     * @param v
     */
    private void dfs(Graph G, int v){
        marked[v] = true;
        //如果当前顶点w没有被搜索过，则将edgeTo[w]设置为v,表示w的前一个顶点为v，并递归搜索与w顶点相通的其他顶点
        for (Integer w : G.adj(v)) {
            if (!marked[w]){
                edgeTo[w] = v;
                dfs(G, w);
            }
        }
    }

    /**
     * 判断v顶点与s顶点是否存在路径
     * @param v
     * @return
     */
    public boolean hasPathTo(int v){
        return marked[v];
    }

    /**
     * 找出从起点s到顶点v的路径(就是该路径经过的顶点)
     * @param v
     * @return
     */
    public Stack pathTo(int v){
        //当前v顶点与s顶点不连通，所以直接返回null，没有路径
        if (!hasPathTo(v)){
            return null;
        }
        Stack<Integer> stack = new Stack<>();
        //第一次把当前顶点存进去，然后将x变换为到达当前顶点的前一个顶点edgeTo[x],在把前一个顶点存进去，
        // 继续将x变化为到达前一个顶点的前一个顶点，继续存，一直到x的值为s为止，相当于逆推法，最后把s放进去
        for (int i = v; i != s ; i = edgeTo[i]) {
            //把当前顶点放入容器
            stack.push(i);
        }
        //把起点s放入容器
        stack.push(s);
        return stack;
    }
}
```

- 测试类

  ```java
  public class DepthFirstPathsTest {
  
      public static void main(String[] args) throws Exception{
          //创建一个BufferReader读取流
          BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(DepthFirstPathsTest.class.getClassLoader().getResourceAsStream("depth_first_search.txt")));
          //读取第一行数据
          int i = Integer.parseInt(bufferedReader.readLine());
          //创建图
          Graph graph = new Graph(i);
          //读取城市道路条数（边数）
          int i1 = Integer.parseInt(bufferedReader.readLine());
          for (int j = 0; j < i1; j++) {
              String s = bufferedReader.readLine();
              String[] split = s.split(" ");
              int i2 = Integer.parseInt(split[0]);
              int i3 = Integer.parseInt(split[1]);
              graph.addEdge(i2,i3);
          }
          //起点为0
          DepthFirstPaths paths = new DepthFirstPaths(graph, 0);
          //查找0-4的路径
          Stack<Integer> stack = paths.pathTo(4);
          StringBuilder builder = new StringBuilder();
          for (Integer o : stack) {
              builder.append(o + "-");
          }
          //删除最后一个-
          builder.deleteCharAt(builder.length()-1);
          System.out.println(builder);
      }
  }
  ```

  输出结果

  ```
  0-2-3-4
  ```



## 6、有向图

### 1、有向图的定义和相关术语

#### 1、定义

> 有向图是一副具有方向性的图，是由一组顶点和一组有方向的边组成的，每条方向的边都连着一对有序的顶点。

#### 2、出度

> 由某个顶点指出的边的个数称为该顶点的出度。

#### 3、入度

> 指向某个顶点的边的个数称为该顶点的入度。

#### 4、有向路径

> 由一系列顶点组成，对于其中的每个顶点都存在一条有向边，从它指向序列中的下一个顶点。

#### 5、有向环

> 一条至少含有一条边，且起点和终点相同的有向路径。



#### 6、一副有向图中两个顶点v和w可能存在以下四种关系

> 1. 没有边相连
> 2. 存在从v到w的边v—>w
> 3. 存在从w到v的边w—>v
> 4. 既存在w到v的边，也存在v到w的边，即双向连接；

### 2、API设计

| 类名     | Digragh                                                      |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Digraph(int V)：创建一个包含V个顶点但不包含边的有向图        |
| 成员方法 | public int V():获取图中顶点的数量<br/>public int E():获取图中边的数量<br/>public void addEdge(int v,int w):向有向图中添加一条边 v->w<br/>public Queue adj(int v)：获取由v指出的边所连接的所有顶点<br/>private Digraph reverse():该图的反向图 |
| 成员变量 | private final int V: 记录顶点数量<br/>private int E: 记录边数量<br/>private Queue[] adj: 邻接表 |

### 3、实现

```JAVA
public class Digraph {

    /**
     * 记录顶点数量
     */
    private final int V;

    /**
     * 记录边数量
     */
    private int E;

    /**
     * 邻接表
     */
    private Queue[] adj;

    /**
     * 创建一个包含V个顶点但不包含边的有向图
     * @param v
     */
    public Digraph(int v){
        this.V = v;
        this.E = 0;
        this.adj = new Queue[v];

        for (int i = 0; i < this.adj.length; i++) {
            adj[i] = new Queue<Integer>();
        }
    }

    /**
     * 获取图中顶点的数量
     * @return
     */
    public int V(){
        return V;
    }

    /**
     * 获取图中边的数量
     * @return
     */
    public int E(){
        return E;
    }

    /**
     * 向有向图中添加一条边 v->w
     * @param v
     * @param w
     */
    public void addEdge(int v,int w){
        //由于有向图中边是有向的，v->w 边，只需要让w出现在v的邻接表中，而不需要让v出现在w的邻接表中
        adj[v].enqueue(w);
        E++;
    }

    /**
     * 获取由v指出的边所连接的所有顶点
     * @param v
     * @return
     */
    public Queue<Integer> adj(int v){
        return adj[v];
    }

    /**
     * 该图的反向图
     * @return
     */
    private Digraph reverse(){
        Digraph digraph = new Digraph(V);
        for (int i = 0; i < V; i++) {
            //得到原图中的v顶点对应的邻接表,原图中的边为 v->w,则反向图中边为w->v;
            for (Integer w : adj(i)) {
                digraph.addEdge(w,i);
            }
        }
        return digraph;
    }
}
```



## 7、拓扑排序

> 在现实生活中，我们经常会同一时间接到很多任务去完成，但是这些任务的完成是有先后次序的。以我们学习java学科为例，我们需要学习很多知识，但是这些知识在学习的过程中是需要按照先后次序来完成的。从java基础，到jsp/servlet，到ssm，到springboot等是个循序渐进且有依赖的过程。在学习jsp前要首先掌握java基础和html基础，学习ssm框架前要掌握jsp/servlet之类才行。



为了简化问题，我们使用整数为顶点编号的标准模型来表示这个案例：



拓扑排序

> 给定一副有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素，此时就可以明确的表示出每个顶点的优先级。



### 1、检测有向图中的环

> 如果学习x课程前必须先学习y课程，学习y课程前必须先学习z课程，学习z课程前必须先学习x课程，那么一定是有问题了，我们就没有办法学习了，因为这三个条件没有办法同时满足。其实这三门课程x、y、z的条件组成了一个环。



因此，如果我们要使用拓扑排序解决优先级问题，首先得保证图中没有环的存在。

#### 1、API设计

| 类名     | DirectedCycle                                                |
| -------- | ------------------------------------------------------------ |
| 构造方法 | public DirectedCycle(Digraph G)：创建一个检测环对象，检测图G中是否有环 |
| 成员方法 | private void dfs(Digraph G,int v)：基于深度优先搜索，检测图G中是否有环<br/>public boolean hasCycle():判断图中是否有环 |
| 成员变量 | private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索<br/>private boolean hasCycle: 记录图中是否有环<br/>private boolean[] onStack:索引代表顶点，使用栈的思想，记录当前顶点有没有已经处于正在搜索的有向路径上 |

#### 2、代码实现

在API中添加了onStack[] 布尔数组，索引为图的顶点，当我们深度搜索时：
1. 在如果当前顶点正在搜索，则把对应的onStack数组中的值改为true，标识进栈；
2. 如果当前顶点搜索完毕，则把对应的onStack数组中的值改为false，标识出栈；
3. 如果即将要搜索某个顶点，但该顶点已经在栈中，则图中有环；



```java
public class DirectedCycle {

    /**
     * 索引代表顶点，值表示当前顶点是否已经被搜索
     */
    private boolean[] marked;
    /**
     * 记录图中是否有环
     */
    private boolean hasCycle;
    /**
     * 索引代表顶点，使用栈的思想，记录当前顶点有没有已经处于正在搜索的有向路径上
     */
    private boolean[] onStack;

    /**
     * 创建一个检测环对象，检测图G中是否有环
     * @param G
     */
    public DirectedCycle(Digraph G){
        //创建一个和图的顶点数一样大小的marked数组
        this.marked = new boolean[G.V()];
        //默认不存在环
        this.hasCycle = false;
        //创建一个和图的顶点数一样的onStack数组
        this.onStack = new boolean[G.V()];

        for (int i = 0; i < G.V(); i++) {
            //如果当前顶点没有搜索过，则搜索
            if (!marked[i]){
                dfs(G,i);
            }
        }
    }

    /**
     * 基于深度优先搜索，检测图G中是否有环
     * @param G
     * @param v
     */
    private void dfs(Digraph G,int v){
        //标记当前顶点已被搜索
        marked[v] = true;
        //让当前顶点进栈
        onStack[v] = true;
        //遍历v顶点的邻接表，得到每一个顶点w
        for (Integer w : G.adj(v)) {
            //如果当前顶点未被搜索，则搜索该顶点
            if (!marked[w]){
                dfs(G,w);
            }
            //如果顶点w已经被搜索过，则查看顶点w是否在栈中，如果在，则证明图中有环，修改hasCycle标记，结束循环
            if (onStack[w]){
                hasCycle = true;
                return;
            }
        }
        onStack[v] = false;
    }

    /**
     * 判断图中是否有环
     * @return
     */
    public boolean hasCycle(){
        return hasCycle;
    }
}
```



### 2、基于深度优先的顶点排序

> 如果要把图中的顶点生成线性序列其实是一件非常简单的事，之前我们学习并使用了多次深度优先搜索，我们会发现其实深度优先搜索有一个特点，那就是在一个连通子图上，每个顶点只会被搜索一次，如果我们能在深度优先搜索的基础上，添加一行代码，只需要将搜索的顶点放入到线性序列的数据结构中，我们就能完成这件事。

#### 1、API设计

| 类名     | DepthFirstOrder                                              |
| -------- | ------------------------------------------------------------ |
| 构造方法 | DepthFirstOrder(Digraph G)：创建一个顶点排序对象，生成顶点线性序列； |
| 成员方法 | private void dfs(Digraph G,int v)：基于深度优先搜索，生成顶点线性序列<br/>public Stack reversePost():获取顶点线性序列 |
| 成员变量 | private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索<br/>private Stack reversePost: 使用栈，存储顶点序列 |

#### 2、顶点排序实现

> 在API的设计中，我们添加了一个栈reversePost用来存储顶点，当我们深度搜索图时，每搜索完毕一个顶点，把该顶点放入到reversePost中，这样就可以实现顶点排序。



```java
public class DepthFirstOrder {

    /**
     * 索引代表顶点，值表示当前顶点是否已经被搜索
     */
    private boolean[] marked;

    /**
     * 使用栈，存储顶点序列
     */
    private Stack reversePost;

    /**
     * 创建一个顶点排序对象，生成顶点线性序列；
     * @param G
     */
    public DepthFirstOrder(Digraph G){
        //初始化
        marked = new boolean[G.V()];
        reversePost = new Stack<Integer>();
        //遍历图中的每一个顶点
        for (int i = 0; i < G.V(); i++) {
            if(!marked[i]){
                dfs(G,i);
            }
        }
    }

    /**
     * 基于深度优先搜索，生成顶点线性序列
     * @param G
     * @param v
     */
    private void dfs(Digraph G,int v){
        //标记当前顶点已被搜索
        marked[v] = true;
        //循环遍历每一个顶点
        for (Integer w : G.adj(v)) {
            if(!marked[w]){
                dfs(G,w);
            }
        }
        //当前顶点已经搜索完毕，让当前顶点入栈
        reversePost.push(v);
    }

    /**
     * :获取顶点线性序列
     * @return
     */
    public Stack reversePost(){
        return reversePost;
    }
}
```



### 3、拓扑排序实现

> 前面已经实现了环的检测以及顶点排序，那么拓扑排序就很简单了，基于一幅图，先检测有没有环，如果没有环，则调用顶点排序即可。

#### 1、API设计

| 类名     | TopoLogical                                                  |
| -------- | ------------------------------------------------------------ |
| 构造方法 | TopoLogical(Digraph G)：构造拓扑排序对象                     |
| 成员方法 | public boolean isCycle()：判断图G是否有环<br/>public Stack order():获取拓扑排序的所有顶点 |
| 成员变量 | private Stack order: 顶点的拓扑排序                          |

#### 2、实现

```java
public class TopologicalSort {
    /**
     * 顶点的拓扑排序
     */
    private Stack<Integer> order;

    /**
     * 构造拓扑排序对象
     * @param G
     */
    public TopologicalSort(Digraph G){
        //创建检测环对象，检测图G中是否有环
        DirectedCycle dCycle = new DirectedCycle(G);
        if(!dCycle.hasCycle()){
            //如果没有环，创建顶点排序对象，进行顶点排序
            DepthFirstOrder depthFirstOrder = new DepthFirstOrder(G);
            order = depthFirstOrder.reversePost();
        }
    }

    /**
     * 判断图G是否有环
     * @return
     */
    public boolean isCycle(){
        return order == null;
    }

    /**
     * 获取拓扑排序的所有顶点
     * @return
     */
    public Stack<Integer> order(){
        return order;
    }
}
```

- 测试类

  ```java
  public class TopologicalSortTest {
  
      public static void main(String[] args) {
          //创建一个有向图
          Digraph digraph = new Digraph(6);
          digraph.addEdge(0,2);
          digraph.addEdge(0,3);
          digraph.addEdge(2,4);
          digraph.addEdge(3,4);
          digraph.addEdge(4,5);
          digraph.addEdge(1,3);
  
          TopologicalSort topologicalSort = new TopologicalSort(digraph);
          Stack<Integer> order = topologicalSort.order();
          for (Integer o : order) {
              System.out.print(o+"->");
          }
      }
  }
  ```

  ```
  1->0->3->2->4->5->
  ```

  

## 8、加权无向图

> 加权无向图是一种为每条边关联一个权重值或是成本的图模型。这种图能够自然地表示许多应用。在一副航空图中，边表示航线，权值则可以表示距离或是费用。在一副电路图中，边表示导线，权值则可能表示导线的长度即成本，或是信号通过这条先所需的时间。此时我们很容易就能想到，最小成本的问题，例如，从西安飞纽约，怎样飞才能使时间成本最低或者是金钱成本最低？
> 在下图中，从顶点0到顶点4有三条路径，分别为0-2-3-4,0-2-4,0-5-3-4,那我们如果要通过那条路径到达4顶点最好呢？此时就要考虑，那条路径的成本最低。



### 1、加权无向图边的表示

> 加权无向图中的边我们就不能简单的使用v-w两个顶点表示了，而必须要给边关联一个权重值，因此我们可以使用对象来描述一条边。

#### 1、API设计

| 类名     | Edge implements Comparable                                   |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Edge(int v,int w,double weight)：通过顶点v和w，以及权重weight值构造一个边对象 |
| 成员方法 | public double weight():获取边的权重值<br/>public int either():获取边上的一个点<br/>public int other(int vertex)):获取边上除了顶点vertex外的另外一个顶点<br/>public int compareTo(Edge that)：比较当前边和参数that边的权重，如果当前边权重大，返回1，如果一样大，返回0，如果当前权重小，返回-1 |
| 成员变量 | private final int v：顶点一<br/>private final int w：顶点二<br/>private final double weight：当前边的权重 |

#### 2、代码实现

```java
public class Edge implements Comparable<Edge>{

    /**
     * 顶点一
     */
    private final int v;
    /**
     * 顶点二
     */
    private final int w;

    /**
     * 当前边的权重
     */
    private final double weight;

    public Edge(int v, int w, double weight) {
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    /**
     * 获取边的权重值
     * @return
     */
    public double weight(){
        return weight;
    }

    /**
     * 获取边上的一个点
     * @return
     */
    public int either(){
        return v;
    }

    /**
     * 获取边上除了顶点vertex外的另外一个顶点
     * @param vertex
     * @return
     */
    public int other(int vertex){
        if (vertex == v){
            return w;
        }else {
            return v;
        }
    }


    @Override
    public int compareTo(Edge o) {
        int temp;
        if(this.weight() == o.weight()){
            temp = 0;
        }else {
            temp = this.weight() > o.weight() ? 1 : -1;
        }
        return temp;
    }
}
```

### 2、加权无向图的实现

#### 1、API设计

| 类名     | EdgeWeightedGraph                                            |
| -------- | ------------------------------------------------------------ |
| 构造方法 | EdgeWeightedGraph(int V)：创建一个含有V个顶点的空加权无向图  |
| 成员方法 | public int V():获取图中顶点的数量<br/>public int E():获取图中边的数量<br/>public void addEdge(Edge e):向加权无向图中添加一条边e<br/>public Queue adj(int v)：获取和顶点v关联的所有边<br/>public Queue edges()：获取加权无向图的所有边 |
| 成员变量 | private final int V: 记录顶点数量<br/>private int E: 记录边数量<br/>private Queue[] adj: 邻接表 |

#### 2、代码实现

```java
public class EdgeWeightedGraph {
    /**
     * 记录顶点数量
     */
    private final int V;
    /**
     * 记录边数量
     */
    private int E;
    /**
     * : 邻接表
     */
    private Queue<Edge>[] adj;

    public EdgeWeightedGraph(int v) {
        this.V = v;
        this.E = 0;
        this.adj = new Queue[v];
        for (int i = 0; i < adj.length; i++) {
            adj[i] = new Queue<Edge>();
        }
    }

    /**
     * 获取图中顶点的数量
     * @return
     */
    public int V(){
        return V;
    }

    /**
     * 获取图中边的数量
     * @return
     */
    public int E(){
        return E;
    }

    /**
     * 向加权无向图中添加一条边e
     * @param e
     */
    public void addEdge(Edge e){
        //获取边上的一个顶点
        int v = e.either();
        //获取边上的另一个顶点
        int w = e.either();
        //因为是无向图，所以边e需要同时出现在两个顶点的邻接表中
        adj[v].enqueue(e);
        adj[w].enqueue(e);
        //边的数量+1
        E++;
    }

    /**
     * 获取和顶点v关联的所有边
     * @param v
     * @return
     */
    public Queue<Edge> adj(int v){
        return adj[v];
    }

    /**
     * 获取加权无向图的所有边
     * @return
     */
    public Queue<Edge> edges(){
        //创建一个队列，存储所有的边
        Queue<Edge> queue = new Queue<>();
        //遍历顶点，拿到顶点的邻接表
        for (int i = 0; i < this.V; i++) {
            for (Edge edge : adj(i)) {
               if(edge.other(i) < V){
                   queue.enqueue(edge);
               }
            }
        }
        return queue;
    }
}
```



## 9、最小生成树

> 之前学习的加权图，我们发现它的边关联了一个权重，那么我们就可以根据这个权重解决最小成本问题，但如何才能找到最小成本对应的顶点和边呢？最小生成树相关算法可以解决。

### 1、最小生成树定义及相关约定

> 图的生成树是它的一棵含有其所有顶点的无环连通子图，一副加权无向图的最小生成树它的一棵权值(树中所有边的权重之和)最小的生成树

![image-20210817112211249](数据结构与算法学习笔记.assets/image-20210817112211249.png)

约定：

> 只考虑连通图。最小生成树的定义说明它只能存在于连通图中，如果图不是连通的，那么分别计算每个连通图子图的最小生成树，合并到一起称为最小生成森林。

![image-20210817112235857](数据结构与算法学习笔记.assets/image-20210817112235857.png)

> 所有边的权重都各不相同。如果不同的边权重可以相同，那么一副图的最小生成树就可能不唯一了，虽然我们的算法可以处理这种情况，但为了好理解，我们约定所有边的权重都各不相同。

#### 1、最小生成树的原理

1. 用一条边接树中的任意两个顶点都会产生一个新的环；

   ![image-20210817112416243](数据结构与算法学习笔记.assets/image-20210817112416243.png)

2. 从树中删除任意一条边，将会得到两棵独立的树；

   ![image-20210817112423145](数据结构与算法学习笔记.assets/image-20210817112423145.png)

#### 2、切分定理

> 要从一副连通图中找出该图的最小生成树，需要通过切分定理完成。

**切分**：

> 将图的所有顶点按照某些规则分为两个非空且没有交集的集合。

**横切边**：

> 连接两个属于不同集合的顶点的边称之为横切边。

例如我们将图中的顶点切分为两个集合，灰色顶点属于一个集合，白色顶点属于另外一个集合，那么效果如下：

![image-20210817113204227](数据结构与算法学习笔记.assets/image-20210817113204227.png)

**切分定理**：

> 在一副加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图中的最小生成树。

![image-20210817113228805](数据结构与算法学习笔记.assets/image-20210817113228805.png)

注意:一次切分产生的多个横切边中，权重最小的边不一定是所有横切边中唯一属于图的最小生成树的边。

![image-20210817113243665](数据结构与算法学习笔记.assets/image-20210817113243665.png)



### 2、贪心算法

> 贪心算法是计算图的最小生成树的基础算法，它的基本原理就是切分定理，使用切分定理找到最小生成树的一条边，不断的重复直到找到最小生成树的所有边。如果图有V个顶点，那么需要找到V-1条边，就可以表示该图的最小生成树。

![image-20210817113858272](数据结构与算法学习笔记.assets/image-20210817113858272.png)

计算图的最小生成树的算法有很多种，但这些算法都可以看做是贪心算法的一种特殊情况，这些算法的不同之处在于：**保存切分和判定权重最小的横切边的方式**。

### 3、Prim算法

> 它的每一步都会为一棵生成中的树添加一条边。一开始这棵树只有一个顶点，然后会向它添加V-1条边，每次总是将下一条连接树中的顶点与不在树中的顶点且权重最小的边加入到树中。

**Prim算法的切分规则**：

> 把最小生成树中的顶点看做是一个集合，把不在最小生成树中的顶点看做是另外一个集合。

![image-20210817114347980](数据结构与算法学习笔记.assets/image-20210817114347980.png)

#### 1、API算法

| 类名     | PrimMST                                                      |
| -------- | ------------------------------------------------------------ |
| 构造方法 | PrimMST(EdgeWeightedGraph G)：根据一副加权无向图，创建最小生成树计算对象； |
| 成员方法 | private void visit(EdgeWeightedGraph G, int v)：将顶点v添加到最小生成树中，并且更新数据<br/>public Queue edges():获取最小生成树的所有边 |
| 成员变量 | private Edge[] edgeTo: 索引代表顶点，值表示当前顶点和最小生成树之间的最短边<br/>private double[] distTo: 索引代表顶点，值表示当前顶点和最小生成树之间的最短边的权重<br/>private boolean[] marked:索引代表顶点，如果当前顶点已经在树中，则值为true，否则为false<br/>private IndexMinPriorityQueue pq:存放树中顶点与非树中顶点之间的有效横切边 |

#### 2、实现原理

> Prim算法始终将图中的顶点切分成两个集合，最小生成树顶点和非最小生成树顶点，通过不断的重复做某些操作，可以逐渐将非最小生成树中的顶点加入到最小生成树中，直到所有的顶点都加入到最小生成树中。

我们在设计API的时候，使用最小索引优先队列存放树中顶点与非树中顶点的有效横切边，那么它是如何表示的呢？

> 我们可以让最小索引优先队列的索引值表示图的顶点，让最小索引优先队列中的值表示从其他某个顶点到当前顶点的边权重。

![image-20210817115235521](数据结构与算法学习笔记.assets/image-20210817115235521.png)

初始化状态，先默认0是最小生成树中的唯一顶点，其他的顶点都不在最小生成树中，此时横切边就是顶点0的邻接表中0-2,0-4,0-6,0-7这四条边，我们只需要将索引优先队列的2、4、6、7索引处分别存储这些边的权重值就可以表示了。

现在只需要从这四条横切边中找出权重最小的边，然后把对应的顶点加进来即可。所以找到0-7这条横切边的权重最小，因此把0-7这条边添加进来，此时0和7属于最小生成树的顶点，其他的不属于，现在顶点7的邻接表中的边也成为了横切边，这时需要做两个作：

- 0-7这条边已经不是横切边了，需要让它失效：只需要调用最小索引优先队列的delMin()方法即可完成；
- 2和4顶点各有两条连接指向最小生成树，需要只保留一条：
- 4-7的权重小于0-4的权重，所以保留4-7，调用索引优先队列的change(4,0.37)即可，
- 0-2的权重小于2-7的权重，所以保留0-2，不需要做额外操作。

![image-20210817115349035](数据结构与算法学习笔记.assets/image-20210817115349035.png)

我们不断重复上面的动作，就可以把所有的顶点添加到最小生成树中。

#### 3、代码实现

```java
public class PrimMST {
    /**
     * 索引代表顶点，值表示当前顶点和最小生成树之间的最短边
     */
    private Edge[] edgeTo;
    /**
     * 索引代表顶点，值表示当前顶点和最小生成树之间的最短边的权重
     */
    private double[] distTo;
    /**
     * 索引代表顶点，如果当前顶点已经在树中，则值为true，否则为false
     */
    private boolean[] marked;
    /**
     * 存放树中顶点与非树中顶点之间的有效横切边
     */
    private IndexMinPriorityQueue pq;

    /**
     * 根据一副加权无向图，创建最小生成树计算对象；
     * @param G
     */
    public PrimMST(EdgeWeightedGraph G){
        //创建一个和图的顶点数一样大小的Edge数组，表示边
        this.edgeTo = new Edge[G.V()];
        //创建一个和图的顶点数一样大小的double数组，表示权重，并且初始化数组中的内容为无穷大，无穷大即表示不存在这样的边
        this.distTo = new double[G.V()];
        Arrays.fill(distTo, Double.POSITIVE_INFINITY);
        //创建一个和图的顶点数一样大小的boolean数组，表示当前顶点是否已经在树中
        this.marked = new boolean[G.V()];
        //创建一个和图的顶点数一样大小的索引优先队列，存储有效横切边
        this.pq = new IndexMinPriorityQueue<>(G.V());
        //默认让顶点0进入树中，0没有与其他顶点连接，初始化distTo[0]=0.0
        distTo[0] = 0.0;
        //初始化pq
        pq.insert(0,0.0);
        //遍历有效边队列
        while (!pq.isEmpty()){
            //找到权重最小的横切边对应的顶点，加入到最小生成树中
            visit(G, pq.delMin());
        }
    }

    /**
     *  将顶点v添加到最小生成树中，并且更新数据
     * @param G
     * @param v
     */
    private void visit(EdgeWeightedGraph G, int v){
        //把顶点v增加在树中
        marked[v] = true;
        //遍历顶点v的邻接表，得到每一条边Edge e
        for (Edge edge : G.adj(v)) {
            //找到另一个顶点w
            int w = edge.other(v);
            if (marked[w]){
                return;
            }
            //如果v-w边e的权重比目前distTo[w]权重小，则需要修正数据
            if (edge.weight() < distTo[w]){
                //把顶点w距离最小生成树的边修改为e
                edgeTo[w] = edge;
                //把顶点w距离最小生成树的边的权重修改为e.weight()
                distTo[w] = edge.weight();
                //如果pq中存储的有效横切边已经包含了w顶点，则需要修正最小索引优先队列w索引关联的权重值
                if (pq.contains(w)) {
                    pq.changeItem(w, edge.weight());
                } else {
                    //如果pq中存储的有效横切边不包含w顶点，则需要向最小索引优先队列中添加v-w和其权重值
                    pq.insert(w, edge.weight());
                }
            }
        }
    }

    /**
     * 获取最小生成树的所有边
     * @return
     */
    public Queue<Edge> edges(){
        Queue<Edge> edges = new Queue<>();
        for (int i = 0; i < marked.length; i++) {
            if (edgeTo[i] != null){
                edges.enqueue(edgeTo[i]);
            }
        }
        return edges;
    }
}
```

- 测试数据

  ```txt
  8
  16
  4 5 0.35
  4 7 0.37
  5 7 0.28
  0 7 0.16
  1 5 0.32
  0 4 0.38
  2 3 0.17
  1 7 0.19
  0 2 0.26
  1 2 0.36
  1 3 0.29
  2 7 0.34
  6 2 0.40
  3 6 0.52
  6 0 0.58
  6 4 0.93
  ```

- 测试类

  ```java
  public class PrimTest {
  
      public static void main(String[] args) throws Exception{
          BufferedReader br = new BufferedReader(new InputStreamReader(Objects.requireNonNull(PrimTest.class.getClassLoader().getResourceAsStream("primTestData.txt"))));
          //读取顶点数目，初始化EdgeWeightedGraph图
          int number = Integer.parseInt(br.readLine());
          EdgeWeightedGraph edgeWeightedGraph = new EdgeWeightedGraph(number);
          //读取边的数目
          int edgeNumber = Integer.parseInt(br.readLine());
          //循环读取每一条边，并调用addEdge方法
          for (int i = 0; i < edgeNumber; i++) {
              String line = br.readLine();
              int v = Integer.parseInt(line.split(" ")[0]);
              int w = Integer.parseInt(line.split(" ")[1]);
              double weight = Double.parseDouble(line.split(" ")[2]);
              edgeWeightedGraph.addEdge(new Edge(v, w, weight));
          }
          //构建PrimMST对象
          PrimMST mst = new PrimMST(edgeWeightedGraph);
          //获取最小生成树的边
          Queue<Edge> edges = mst.edges();
          //打印输出
          for (Edge edge : edges) {
              if (edge!=null){
                  System.out.println(edge.either() + "-" + edge.other(edge.either()) + "::" + edge.weight());
              }
          }
      }
  }
  ```



### 4、kruskal算法

> kruskal算法是计算一副加权无向图的最小生成树的另外一种算法，它的主要思想是按照边的权重(从小到大)处理它们，将边加入最小生成树中，加入的边不会与已经加入最小生成树的边构成环，直到树中含有V-1条边为止。

**kruskal算法和prim算法的区别**：

> Prim算法是一条边一条边的构造最小生成树，每一步都为一棵树添加一条边。
>
> kruskal算法构造最小生成树的时候也是一条边一条边地构造，但它的切分规则是不一样的。它每一次寻找的边会连接一片森林中的两棵树。如果一副加权无向图由V个顶点组成，初始化情况下每个顶点都构成一棵独立的树，则V个顶点对应V棵树，组成一片森林，kruskal算法每一次处理都会将两棵树合并为一棵树，直到整个森林中只剩一棵树为止。

![image-20210817135440325](数据结构与算法学习笔记.assets/image-20210817135440325.png)

#### 1、API设计

| 类名     | KruskalMST                                                   |
| -------- | ------------------------------------------------------------ |
| 构造函数 | KruskalMST(EdgeWeightedGraph G)：根据一副加权无向图，创建最小生成树计算对象； |
| 成员方法 | public Queue edges():获取最小生成树的所有边                  |
| 成员变量 | private Queue mst：保存最小生成树的所有边<br/>private UF_Tree_Weighted uf: 索引代表顶点，使用uf.connect(v,w)可以判断顶点v和顶点w是否在同一颗树中，使用uf.union(v,w)可以把顶点v所在的树和顶点w所在的树合并<br/>private MinPriorityQueue pq: 存储图中所有的边，使用最小优先队列，对边按照权重进行排序 |

#### 2实现原理

> 在设计API的时候，使用了一个MinPriorityQueue pq存储图中所有的边，每次使用pq.delMin()取出权重最小的边，并得到该边关联的两个顶点v和w，通过uf.connect(v,w)判断v和w是否已经连通，如果连通，则证明这两个顶点在同一棵树中，那么就不能再把这条边添加到最小生成树中，因为在一棵树的任意两个顶点上添加一条边，都会形成环，而最小生成树不能有环的存在，如果不连通，则通过uf.connect(v,w)把顶点v所在的树和顶点w所在的树合并成一棵树，并把这条边加入到mst队列中，这样如果把所有的边处理完，最终mst中存储的就是最小生树的所有边。

![image-20210817135705268](数据结构与算法学习笔记.assets/image-20210817135705268.png)

#### 3、代码实现

```java
public class KruskalMST {
    /**
     * 保存最小生成树的所有边
     */
    private Queue<Edge> mst;
    /**
     * :索引代表顶点，使用uf.connect(v,w)可以判断顶点v和顶点w是否在同一颗树中
     * 使用uf.union(v,w)可以把顶点v所在的树和顶点w所在的树合并
     */
    private UFTreeWeighted uf;
    /**
     * 存储图中所有的边，使用最小优先队列，对边按照权重进行排序
     */
    private MinPriorityQueue<Edge> pq;

    public KruskalMST(EdgeWeightedGraph G){
        //初始化mst队列
        this.mst = new Queue<Edge>();
        //初始化并查集对象uf,容量和图的顶点数相同
        this.uf = new UFTreeWeighted(G.V());
        //初始化最小优先队列pq，容量比图的边的数量大1，并把图中所有的边放入pq中
        this.pq = new MinPriorityQueue<>(G.E()+1);
        for (Edge edge : G.edges()) {
            pq.insert(edge);
        }
        //如果优先队列pq不为空，也就是还有边未处理，并且mst中的边还不到V-1条，继续遍历
        while (!pq.isEmpty() && mst.size() < G.V() - 1) {
            //取出pq中权重最小的边e
            Edge e = pq.delMin();
            //获取边e的两个顶点v和w
            int v = e.either();
            int w = e.other(v);
            /*
            通过uf.connect(v,w)判断v和w是否已经连通，
            如果连通:
            则证明这两个顶点在同一棵树中，那么就不能再把这条边添加到最小生成树中，因为在一棵
            树的任意两个顶点上添加一条边，都会形成环，而最小生成树不能有环的存在;

            如果不连通:
            则通过uf.connect(v,w)把顶点v所在的树和顶点w所在的树合并成一棵树,并把这条边加入到mst队列中
            */
            if (uf.connected(v,w)){
                continue;
            }
            uf.union(v,w);
            mst.enqueue(e);
        }
    }

    /**
     * 获取最小生成树的所有边
     * @return
     */
    public Queue<Edge> edges() {
        return mst;
    }
}

```

- 测试类

  ```java
  public class KruskalTest {
  
      public static void main(String[] args) throws Exception{
          BufferedReader br = new BufferedReader(new InputStreamReader(Objects.requireNonNull(KruskalTest.class.getClassLoader().getResourceAsStream("primTestData.txt"))));
          //读取顶点数目，初始化EdgeWeightedGraph图
          int number = Integer.parseInt(br.readLine());
          EdgeWeightedGraph edgeWeightedGraph = new EdgeWeightedGraph(number);
          //读取边的数目
          int edgeNumber = Integer.parseInt(br.readLine());
          //循环读取每一条边，并调用addEdge方法
          for (int i = 0; i < edgeNumber; i++) {
              String line = br.readLine();
              int v = Integer.parseInt(line.split(" ")[0]);
              int w = Integer.parseInt(line.split(" ")[1]);
              double weight = Double.parseDouble(line.split(" ")[2]);
              edgeWeightedGraph.addEdge(new Edge(v, w, weight));
          }
          //构建PrimMST对象
          KruskalMST mst = new KruskalMST(edgeWeightedGraph);
          //获取最小生成树的边
          Queue<Edge> edges = mst.edges();
          //打印输出
          for (Edge edge : edges) {
              if (edge!=null){
                  System.out.println(edge.either() + "-" + edge.other(edge.either()) + "::" + edge.weight());
              }
          }
      }
  }
  ```

  

## 10、加权有向图

### 1、加权有向图的表示

#### 1、API设计

| 类名     | DirectedEdge                                                 |
| -------- | ------------------------------------------------------------ |
| 构造方法 | DirectedEdge(int v,int w,double weight)：通过顶点v和w，以及权重weight值构造一个边对象 |
| 成员方法 | public double weight():获取边的权重值<br/>public int from():获取有向边的起点<br/>public int to():获取有向边的终点 |
| 成员变量 | private final int v：起点<br/>private final int w：终点<br/>private final double weight：当前边的权重 |

#### 2、代码实现

```java
public class DirectedEdge {

    /**
     * 起点
     */
    private final int v;

    /**
     * 终点
     */
    private final int w;

    /**
     * 当前边的权重
     */
    private final double weight;


    public DirectedEdge(int v, int w, double weight) {
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    /**
     * 获取边的权重值
     * @return
     */
    public double weight(){
        return weight;
    }

    /**
     * 获取有向边的起点
     * @return
     */
    public int from(){
        return v;
    }

    /**
     * :获取有向边的终点
     * @return
     */
    public int to(){
        return w;
    }
}
```

### 2、加权有向图的实现

> 之前我们已经完成了有向图，在有向图的基础上，我们只需要把边的表示切换成DirectedEdge对象即可。

#### 1、API设计

| 类名     | EdgeWeightedDigraph                                          |
| -------- | ------------------------------------------------------------ |
| 构造方法 | EdgeWeightedDigraph(int V)：创建一个含有V个顶点的空加权有向图 |
| 成员方法 | public int V():获取图中顶点的数量<br/>public int E():获取图中边的数量<br/>public void addEdge(DirectedEdge e):向加权有向图中添加一条边e<br/>public Queue adj(int v)：获取由顶点v指出的所有的边<br/>public Queue edges()：获取加权有向图的所有边 |
| 成员变量 | private final int V: 记录顶点数量<br/>private int E: 记录边数量<br/>private Queue[] adj: 邻接表 |

#### 2、代码实现

```java
public class EdgeWeightedDigraph {

    /**
     * : 记录顶点数量
     */
    private final int V;
    /**
     * : 记录边数量
     */
    private int E;
    /**
     * : 邻接表
     */
    private Queue<DirectedEdge>[] adj;

    public EdgeWeightedDigraph(int v) {
        //初始化顶点数
        this.V = v;
        //初始化边数量
        this.E = 0;
        this.adj = new Queue[v];
        //初始化邻接表的空队列
        for (int i = 0; i < this.adj.length; i++) {
            adj[i] = new Queue<DirectedEdge>();
        }
    }

    /**
     * 获取图中顶点的数量
     * @return
     */
    public int V(){
        return V;
    }

    /**
     * 获取边的数量
     * @return
     */
    public int E(){
        return E;
    }

    /**
     * 向加权有向图添加一条边
     * @param e
     */
    public void addEdge(DirectedEdge e){
        //获取有向边的起点
        int from = e.from();
        //因为是有向图，所以边e只需要出现在起点v的邻接表中
        adj[from].enqueue(e);
        //边的数量+1
        E++;
    }

    /**
     * 获取由顶点v指出的所有的边
     * @param v
     * @return
     */
    public Queue<DirectedEdge> adj(int v){
        return adj[v];
    }

    /**
     * 获取加权有向图的所有边
     * @return
     */
    public Queue<DirectedEdge> edges(){
        Queue<DirectedEdge> queue = new Queue<>();
        //遍历顶点，拿到每个顶点的邻接表
        for (int i = 0; i < this.V; i++) {
            //遍历邻接表，拿到邻接表中的每条边存储到队列中
            for (DirectedEdge e : adj(i)) {
                queue.enqueue(e);
            }
        }
        return queue;
    }
}
```



## 11、最短路径

### 1、最短路径定义及性质

#### 1、定义

> 在一副加权有向图中，从顶点s到顶点t的最短路径是所有从顶点s到顶点t的路径中总权重最小的那条路径。

![image-20210817152057498](数据结构与算法学习笔记.assets/image-20210817152057498.png)

#### 2、性质

> 1. 路径具有方向性；
> 2. **权重不一定等价于距离。权重可以是距离、时间、花费等内容，权重最小指的是成本最低**
> 3. 只考虑连通图。一副图中并不是所有的顶点都是可达的，如果s和t不可达，那么它们之间也就不存在最短路径，为了简化问题，这里只考虑连通图。
> 4. 最短路径不一定是唯一的。从一个顶点到达另外一个顶点的权重最小的路径可能会有很多条，这里只需要找出一条即可。

**最短路径树**：

> 给定一副加权有向图和一个顶点s，以s为起点的一棵最短路径树是图的一副子图，它包含顶点s以及从s可达的所有顶点。这棵有向树的根结点为s，树的每条路径都是有向图中的一条最短路径。

### 2、最短路径树的API设计

> 计算最短路径树的经典算法是dijstra算法

| 类名     | DijkstraSP                                                   |
| -------- | ------------------------------------------------------------ |
| 构造方法 | public DijkstraSP(EdgeWeightedDigraph G, int s)：根据一副加权有向图G和顶点s，创建一个计算顶点为s的最短路径树对象 |
| 成员方法 | private void relax(EdgeWeightedDigraph G, int v)：松弛图G中的顶点v<br/>public double distTo(int v):获取从顶点s到顶点v的最短路径的总权重<br/>public boolean hasPathTo(int v):判断从顶点s到顶点v是否可达<br/>public Queue pathTo(int v):查询从起点s到顶点v的最短路径中所有的边 |
| 成员变量 | private DirectedEdge[] edgeTo: 索引代表顶点，值表示从顶点s到当前顶点的最短路径上的最后一条边<br/>private double[] distTo: 索引代表顶点，值从顶点s到当前顶点的最短路径的总权重<br/>private IndexMinPriorityQueue pq:存放树中顶点与非树中顶点之间的有效横切边 |

### 3、松弛技术

松弛这个词来源于生活：一条橡皮筋沿着两个顶点的某条路径紧紧展开，如果这两个顶点之间的路径不止一条，还有存在更短的路径，那么把皮筋转移到更短的路径上，皮筋就可以放松了。

![image-20210817152441932](数据结构与算法学习笔记.assets/image-20210817152441932.png)

松弛这种简单的原理刚好可以用来计算最短路径树。

> 在我们的API中，需要用到两个成员变量edgeTo和distTo，分别存储边和权重。一开始给定一幅图G和顶点s，我们只知道图的边以及这些边的权重，其他的一无所知，此时初始化顶点s到顶点s的最短路径的总权重disto[s]=0；顶点s到其他顶点的总权重默认为无穷大，随着算法的执行，不断的使用松弛技术处理图的边和顶点，并按一定的条件更新edgeTo和distTo中的数据，最终就可以得到最短路劲树。

#### 1、边的松弛

放松边v->w意味着检查从s到w的最短路径是否先从s到v，然后再从v到w？

> 如果是，则v-w这条边需要加入到最短路径树中，更新edgeTo和distTo中的内容：edgeTo[w]=表示v->w这条边的DirectedEdge对象，distTo[w]=distTo[v]+v->w这条边的权重；
>
> 如果不是，则忽略v->w这条边。

![image-20210817152641423](数据结构与算法学习笔记.assets/image-20210817152641423.png)



#### 2、顶点的松弛

> 顶点的松弛是基于边的松弛完成的，只需要把某个顶点指出的所有边松弛，那么该顶点就松弛完毕。例如要松弛顶点v，只需要遍历v的邻接表，把每一条边都松弛，那么顶点v就松弛了。

如果把起点设置为顶点0，那么找出起点0到顶点6的最短路径0->2->7>3->6的过程如下:

![image-20210817152721070](数据结构与算法学习笔记.assets/image-20210817152721070.png)

### 4、 Dijstra算法实现

> Disjstra算法的实现和Prim算法很类似，构造最短路径树的每一步都是向这棵树中添加一条新的边，而这条新的边是有效横切边pq队列中的权重最小的边。

```java
public class DijkstraSP {

    /**
     * 索引代表顶点，值表示从顶点s到当前顶点的最短路径上的最后一条边
     */
    private DirectedEdge[] edgeTo;
    /**
     * 索引代表顶点，值从顶点s到当前顶点的最短路径的总权重
     */
    private double[] distTo;

    /**
     * 存放树中顶点与非树中顶点之间的有效横切边
     */
    private IndexMinPriorityQueue<Double> pq;
    /**
     * 根据一副加权有向图G和顶点s，创建一个计算顶点为s的最短路径树对象
     */
    public DijkstraSP(EdgeWeightedDigraph G, int s){
        //创建一个和图的顶点数一样的数组
        this.edgeTo = new DirectedEdge[G.V()];
        this.distTo = new double[G.V()];
        for (int i = 0; i < distTo.length; i++) {
            distTo[i] = Double.POSITIVE_INFINITY;
        }
        //创建一个和图的顶点数一样大小的索引优先队列，存储有效横切边
        this.pq = new IndexMinPriorityQueue<>(G.V());
        //默认让顶点s进入树中，但s顶点目前没有与树中其他的顶点相连接，因此初始化distTo[s]=0.0
        distTo[s] = 0.0;
        //使用顶点s和权重0.0初始化pq
        pq.insert(s, 0.0);
        //遍历有效边队列
        while (!pq.isEmpty()) {
        //松弛图G中的顶点
            relax(G, pq.delMin());
        }
    }

    /**
     * ：松弛图G中的顶点v
     * @param G
     * @param v
     */
    private void relax(EdgeWeightedDigraph G, int v){
        //松弛顶点v就是松弛顶点v邻接表中的每一条边，遍历邻接表
        for (DirectedEdge e : G.adj(v)) {
            //获取边e的终点
            int w = e.to();
            //起点s到顶点w的权重是否大于起点s到顶点v的权重+边e的权重,如果大于，
            // 则修改s->w的路径：edgeTo[w]=e,并修改distTo[v] = distTo[v]+e.weitht(),如果不大于，则忽略
            if (distTo(w)>distTo(v)+e.weight()){
                distTo[w]=distTo[v]+e.weight();
                edgeTo[w]=e;
                //如果顶点w已经存在于优先队列pq中，则重置顶点w的权重
                if (pq.contains(w)){
                    pq.changeItem(w,distTo(w));
                }else{
                    //如果顶点w没有出现在优先队列pq中，则把顶点w及其权重加入到pq中
                    pq.insert(w,distTo(w));
                }
            }
        }
    }

    /**
     * :获取从顶点s到顶点v的最短路径的总权重
     * @param v
     * @return
     */
    public double distTo(int v){
        return distTo[v];
    }

    /**
     * :判断从顶点s到顶点v是否可达
     * @param v
     * @return
     */
    public boolean hasPathTo(int v){
        return distTo[v]<Double.POSITIVE_INFINITY;
    }

    /**
     * :查询从起点s到顶点v的最短路径中所有的边
     * @param v
     * @return
     */
    public Queue pathTo(int v){
        //如果顶点s到v不可达，则返回null
        if (!hasPathTo(v)){
            return null;
        }
        //创建队列Queue保存最短路径的边
        Queue<DirectedEdge> edges = new Queue<>();
        //从顶点v开始，逆向寻找，一直找到顶点s为止，而起点s为最短路劲树的根结点，所以edgeTo[s]=null;
        DirectedEdge e;
        while(true){
            e = edgeTo[v];
            if (e==null){
                break;
            }
            edges.enqueue(e);
            v = e.from();
        }
        return edges;
    }
}
```

- 测试类

```java
public class DijkstraSPTest {

    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(Objects.requireNonNull(DijkstraSPTest.class.getClassLoader().getResourceAsStream("primTestData.txt"))));
        //读取顶点数目，初始化EdgeWeightedGraph图
        int number = Integer.parseInt(br.readLine());
        EdgeWeightedDigraph edgeWeightedGraph = new EdgeWeightedDigraph(number);
        //读取边的数目
        int edgeNumber = Integer.parseInt(br.readLine());
        //循环读取每一条边，并调用addEdge方法
        for (int i = 0; i < edgeNumber; i++) {
            String line = br.readLine();
            int v = Integer.parseInt(line.split(" ")[0]);
            int w = Integer.parseInt(line.split(" ")[1]);
            double weight = Double.parseDouble(line.split(" ")[2]);
            edgeWeightedGraph.addEdge(new DirectedEdge(v, w, weight));
        }
        //构建PrimMST对象
        DijkstraSP mst = new DijkstraSP(edgeWeightedGraph,0);
        //获取起点0到顶点6的最短路径
        Queue<DirectedEdge> edges = mst.pathTo(6);
            //打印输出
        for (DirectedEdge edge : edges) {
            System.out.println(edge.from() + "->" + edge.to() + "::" + edge.weight());
        }
    }
}
```

